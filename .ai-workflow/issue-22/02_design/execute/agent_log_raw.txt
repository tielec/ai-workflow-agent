{"type":"system","subtype":"init","cwd":"/tmp/jenkins-0c28f259/workspace/AI_Workflow/ai_workflow_orchestrator","session_id":"7afadee8-ca2a-4778-85f9-6024072867a1","tools":["Task","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","BashOutput","KillShell","Skill","SlashCommand"],"mcp_servers":[],"model":"claude-sonnet-4-5-20250929","permissionMode":"bypassPermissions","slash_commands":["compact","context","cost","init","output-style:new","pr-comments","release-notes","todos","review","security-review"],"apiKeySource":"none","claude_code_version":"2.0.21","output_style":"default","agents":["general-purpose","statusline-setup","output-style-setup","Explore"],"uuid":"78fe151e-da0c-4fbe-8192-62db1328e51f"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LFEovAEJS2iymXQsN31FJ1","type":"message","role":"assistant","content":[{"type":"text","text":"# 詳細設計書 - Issue #22\n\n**Issue番号**: #22  \n**タイトル**: [REFACTOR] CLI コマンド処理の分離 (main.ts リファクタリング)  \n**作成日**: 2025-01-20  \n**ステータス**: Design Phase\n\n---\n\n## 1. アーキテクチャ設計\n\n### 1.1 システム全体図\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     CLI Entry Point                         │\n│                    (src/main.ts)                            │\n│                    ~200 lines                               │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ - Commander definitions                              │  │\n│  │ - Command routing                                    │  │\n│  │ - Error handling (reportFatalError)                 │  │\n│  │ - Execution summary (reportExecutionSummary)        │  │\n│  │ - Phase validation (isValidPhaseName, PHASE_ORDER)  │  │\n│  └──────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n                            │\n        ┌───────────────────┼───────────────────┐\n        │                   │                   │\n        ▼                   ▼                   ▼\n┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐\n│ Init Command    │ │Execute Command  │ │List Presets     │\n│ Module          │ │ Module          │ │ Module          │\n│ (commands/      │ │ (commands/      │ │ (commands/      │\n│  init.ts)       │ │  execute.ts)    │ │  list-presets.  │\n│                 │ │                 │ │  ts)            │\n│ ~300 lines      │ │ ~500 lines      │ │ ~80 lines       │\n└─────────────────┘ └─────────────────┘ └─────────────────┘\n        │                   │                   │\n        └───────────────────┼───────────────────┘\n                            ▼\n        ┌───────────────────────────────────────┐\n        │   Shared Utilities & Types            │\n        │                                       │\n        │  ┌─────────────────────────────────┐ │\n        │  │ Repository Utils                │ │\n        │  │ (core/repository-utils.ts)      │ │\n        │  │ - parseIssueUrl                 │ │\n        │  │ - resolveLocalRepoPath          │ │\n        │  │ - findWorkflowMetadata          │ │\n        │  │ - getRepoRoot                   │ │\n        │  └─────────────────────────────────┘ │\n        │                                       │\n        │  ┌─────────────────────────────────┐ │\n        │  │ Command Types                   │ │\n        │  │ (types/commands.ts)             │ │\n        │  │ - PhaseContext                  │ │\n        │  │ - ExecutionSummary              │ │\n        │  │ - PhaseResultMap                │ │\n        │  │ - IssueInfo                     │ │\n        │  │ - BranchValidationResult        │ │\n        │  └─────────────────────────────────┘ │\n        └───────────────────────────────────────┘\n                            │\n        ┌───────────────────┴───────────────────┐\n        ▼                                       ▼\n┌─────────────────┐                 ┌─────────────────┐\n│ Existing Core   │                 │ Existing Phases │\n│ Modules         │                 │ Modules         │\n│ - MetadataManager│                │ - BasePhase     │\n│ - GitManager    │                 │ - PlanningPhase │\n│ - GitHubClient  │                 │ - ...           │\n│ - CodexAgent    │                 │                 │\n│ - ClaudeAgent   │                 │                 │\n└─────────────────┘                 └─────────────────┘\n```\n\n### 1.2 コンポーネント間の関係\n\n#### 依存関係フロー\n\n```\nmain.ts\n  ├── commands/init.ts\n  │     ├── core/repository-utils.ts\n  │     ├── types/commands.ts\n  │     ├── core/metadata-manager.ts\n  │     ├── core/git-manager.ts\n  │     └── core/github-client.ts\n  │\n  ├── commands/execute.ts\n  │     ├── core/repository-utils.ts\n  │     ├── types/commands.ts\n  │     ├── core/metadata-manager.ts\n  │     ├── core/git-manager.ts\n  │     ├── core/codex-agent-client.ts\n  │     ├── core/claude-agent-client.ts\n  │     ├── core/phase-dependencies.ts\n  │     └── phases/*.ts\n  │\n  ├── commands/list-presets.ts\n  │     └── core/phase-dependencies.ts\n  │\n  └── commands/review.ts (existing location)\n        ├── core/repository-utils.ts\n        ├── types/commands.ts\n        └── core/metadata-manager.ts\n```\n\n**循環依存の回避戦略**:\n- コマンドモジュール間は直接依存しない\n- 共有ロジックは `core/repository-utils.ts` と `types/commands.ts` に集約\n- すべてのコマンドモジュールは main.ts から一方向にimportされる\n\n### 1.3 データフロー\n\n#### init コマンド\n\n```\nUser Input (--issue-url, --branch)\n  ↓\nmain.ts (commander parsing)\n  ↓\ncommands/init.ts::handleInitCommand()\n  ↓\nrepository-utils.ts::parseIssueUrl()\n  → IssueInfo { owner, repo, issueNumber }\n  ↓\nrepository-utils.ts::resolveLocalRepoPath()\n  → Local repository path\n  ↓\ncommands/init.ts::validateBranchName()\n  → BranchValidationResult\n  ↓\ncommands/init.ts::resolveBranchName()\n  → Resolved branch name\n  ↓\nGitManager::createBranch()\n  ↓\nMetadataManager::createMetadata()\n  → .ai-workflow/issue-{num}/metadata.json\n  ↓\nGitHubClient::createDraftPR()\n  ↓\nConsole output (success message)\n```\n\n#### execute コマンド\n\n```\nUser Input (--issue, --phase, --preset, --agent)\n  ↓\nmain.ts (commander parsing + preset resolution)\n  ↓\ncommands/execute.ts::handleExecuteCommand()\n  ↓\nrepository-utils.ts::findWorkflowMetadata()\n  → { repoRoot, metadataPath }\n  ↓\nMetadataManager::loadMetadata()\n  → WorkflowState\n  ↓\ncommands/execute.ts::resolvePresetName()\n  → Canonical phase names\n  ↓\ncommands/execute.ts::canResumeWorkflow()\n  → Resume decision\n  ↓\ncommands/execute.ts::executePhasesSequential()\n  ↓\n  ┌─ Loop for each phase ─┐\n  │                        │\n  │ createPhaseInstance()  │\n  │   ↓                    │\n  │ BasePhase.run()        │\n  │   ├─ execute()         │\n  │   ├─ review()          │\n  │   └─ revise()          │\n  │   ↓                    │\n  │ MetadataManager.update()│\n  └────────────────────────┘\n  ↓\nExecutionSummary\n  ↓\nmain.ts::reportExecutionSummary()\n  ↓\nConsole output\n```\n\n---\n\n## 2. 実装戦略判断\n\n### 実装戦略: REFACTOR\n\n#### 判断根拠\n\n1. **既存コード改善が中心**\n   - `main.ts` (1309行) から責務を分離し、200行以下に削減することが主目的\n   - 新規機能の追加はなく、既存の4つのコマンド（init/execute/review/list-presets）を分離\n\n2. **機能追加なし**\n   - CLI インターフェース（コマンド、オプション）は変更しない\n   - 既存の動作を完全に維持（後方互換性100%）\n   - Issue要件でも「破壊的変更なし」が明示されている\n\n3. **構造改善**\n   - SOLID原則（単一責任原則）の適用が主目的\n   - コマンドごとの責務を明確化し、テスト容易性を向上\n   - 既存のテスト（ユニットテスト18件 + 統合テスト18件）を維持\n\n4. **拡張性向上**\n   - 将来的な新規コマンド追加を容易にする\n   - モジュール間の疎結合を実現\n\n---\n\n## 3. テスト戦略判断\n\n### テスト戦略: UNIT_INTEGRATION\n\n#### 判断根拠\n\n1. **ユニットテスト**\n   - モジュール分割後の各コマンドハンドラは独立してテスト可能\n   - 新規作成する各コマンドモジュールのロジックをユニットテストで検証\n   - 例:\n     - `commands/init.ts::validateBranchName()` のバリデーションロジック\n     - `commands/execute.ts::resolvePresetName()` のプリセット解決ロジック\n     - `commands/execute.ts::canResumeWorkflow()` のレジューム判定ロジック\n\n2. **統合テスト**\n   - 既存の統合テスト（18件）を再利用し、CLI全体の動作を検証\n   - エンドツーエンドの動作確認（CLI → コマンドモジュール → Core → Git/GitHub）\n   - 例:\n     - `tests/integration/workflow-init-cleanup.test.ts` - ワークフロー初期化とクリーンアップ\n     - `tests/integration/preset-execution.test.ts` - プリセット実行の統合テスト\n     - `tests/integration/multi-repo-workflow.test.ts` - マルチリポジトリワークフロー\n\n3. **BDD不要の理由**\n   - エンドユーザー向けの新機能追加ではなく、内部リファクタリングのため\n   - ユーザーストーリーベースのテストは既存の統合テストでカバー済み\n   - 既存のCLIインターフェースを変更しないため、新規のBDDシナリオは不要\n\n---\n\n## 4. テストコード戦略判断\n\n### テストコード戦略: BOTH_TEST\n\n#### 判断根拠\n\n1. **EXTEND_TEST（既存テストの拡張）**\n   - 既存のユニットテスト（`tests/unit/main-preset-resolution.test.ts` 等）のimport文を修正\n   - 既存テスト: 220行（main.tsのプライベート関数をテスト用に再現）\n   - 対応方針: モジュール分離後は正式なexportされた関数をテストするよう変更\n   - 例:\n     ```typescript\n     // Before (main-preset-resolution.test.ts)\n     // main.tsのプライベート関数を再現してテスト\n     \n     // After\n     import { resolvePresetName } from '../../src/commands/execute.js';\n     // 正式なexport関数をテスト\n     ```\n\n2. **CREATE_TEST（新規テスト作成）**\n   - 新規コマンドモジュールのユニットテストを作成\n   - 作成するテストファイル:\n     - `tests/unit/commands/init.test.ts` - 初期化コマンドのロジックテスト\n     - `tests/unit/commands/execute.test.ts` - 実行コマンドのロジックテスト（エージェント選択、プリセット解決等）\n     - `tests/unit/commands/list-presets.test.ts` - プリセット一覧表示のロジックテスト\n\n3. **BOTH適用の理由**\n   - 既存テストは互換性維持のために拡張が必要（import修正、テストロジック更新）\n   - 新規モジュールは独立したテストカバレッジが必要（モジュール単位のテスト）\n   - 両方を実施することで、リグレッション防止と新規コード品質保証の両立を実現\n\n---\n\n## 5. 影響範囲分析\n\n### 5.1 既存コードへの影響\n\n#### 変更が必要な既存ファイル\n\n1. **src/main.ts** (1309行 → 200行以下に削減)\n   - コマンドルーターとしての役割のみ残す\n   - 削除する関数:\n     - `handleInitCommand` (229行: L229-L450)\n     - `handleExecuteCommand` (346行: L452-L798)\n     - `handleReviewCommand` (18行: L800-L817)\n     - `listPresets` (26行: L1201-L1225)\n   - 移動する関数:\n     - `parseIssueUrl` → `core/repository-utils.ts`\n     - `resolveLocalRepoPath` → `core/repository-utils.ts`\n     - `findWorkflowMetadata` → `core/repository-utils.ts`\n     - `validateBranchName` → `commands/init.ts`\n     - `resolveBranchName` → `commands/init.ts`\n     - `resolvePresetName` → `commands/execute.ts`\n     - `getPresetPhases` → `commands/execute.ts`\n     - `canResumeWorkflow` → `commands/execute.ts`\n     - `executePhasesSequential` → `commands/execute.ts`\n     - `createPhaseInstance` → `commands/execute.ts`\n   - 残す関数:\n     - `runCli()` - CLIエントリーポイント\n     - `reportFatalError()` - エラーハンドリング\n     - `reportExecutionSummary()` - 実行サマリー表示\n     - `isValidPhaseName()` - フェーズ名バリデーション\n     - `PHASE_ORDER` 定数\n\n2. **tests/unit/main-preset-resolution.test.ts** (220行)\n   - import文の修正: `resolvePresetName` を `src/commands/execute.ts` からimport\n   - テストロジックの修正: 再現コードを削除し、正式なexportされた関数を使用\n\n3. **tests/integration/workflow-init-cleanup.test.ts**\n   - import文の修正: 必要に応じて `src/commands/init.ts` からimport\n   - テストケース自体は変更不要（動作の互換性維持）\n\n4. **tests/unit/repository-resolution.test.ts**\n   - import文の修正: `parseIssueUrl`, `resolveLocalRepoPath`, `findWorkflowMetadata` を `core/repository-utils.ts` からimport\n\n5. **tests/unit/branch-validation.test.ts**\n   - import文の修正: `validateBranchName`, `resolveBranchName` を `commands/init.ts` からimport\n\n### 5.2 依存関係の変更\n\n#### 新規依存の追加\n\n- **なし** - 既存の依存関係（commander, fs-extra, simple-git等）のみ使用\n\n#### 既存依存の変更\n\n- **なし** - 依存ライブラリのバージョン変更は不要\n\n### 5.3 マイグレーション要否\n\n#### データベーススキーマ変更\n\n- **なし**\n\n#### 設定ファイル変更\n\n- **なし** - package.json, tsconfig.jsonの変更不要\n- **ビルドスクリプト**: 既存のビルドスクリプト（`npm run build`）で自動的に新規ファイルをコンパイル\n\n#### 環境変数変更\n\n- **なし** - 既存の環境変数（GITHUB_TOKEN, CODEX_API_KEY等）をそのまま使用\n\n---\n\n## 6. 変更・追加ファイルリスト\n\n### 6.1 新規作成ファイル\n\n#### コマンドモジュール\n\n1. **src/commands/init.ts** (約250~300行)\n   - `handleInitCommand()` 関数\n   - `validateBranchName()` 関数\n   - `resolveBranchName()` 関数\n\n2. **src/commands/execute.ts** (約450~500行)\n   - `handleExecuteCommand()` 関数\n   - `executePhasesSequential()` 関数\n   - `executePhasesFrom()` 関数\n   - `createPhaseInstance()` 関数\n   - `resolvePresetName()` 関数\n   - `getPresetPhases()` 関数\n   - `canResumeWorkflow()` 関数\n   - `loadExternalDocuments()` 関数\n   - `resetMetadata()` 関数\n\n3. **src/commands/list-presets.ts** (約50~80行)\n   - `listPresets()` 関数\n\n4. **src/commands/review.ts** (約50行)\n   - `handleReviewCommand()` 関数（現在はmain.tsに存在）\n\n#### 共有モジュール\n\n5. **src/core/repository-utils.ts** (約200行)\n   - `parseIssueUrl()` 関数（main.tsから移動）\n   - `resolveLocalRepoPath()` 関数（main.tsから移動）\n   - `findWorkflowMetadata()` 関数（main.tsから移動）\n   - `getRepoRoot()` 関数（新規export）\n\n6. **src/types/commands.ts** (約100行)\n   - `PhaseContext` 型定義\n   - `ExecutionSummary` 型定義\n   - `PhaseResultMap` 型定義\n   - `IssueInfo` 型定義（main.tsから移動）\n   - `BranchValidationResult` 型定義\n\n#### テストファイル\n\n7. **tests/unit/commands/init.test.ts** (約150~200行)\n   - 初期化コマンドのユニットテスト\n   - ブランチ名バリデーション、Issue URL解析、リポジトリ解決のテスト\n\n8. **tests/unit/commands/execute.test.ts** (約200~250行)\n   - 実行コマンドのユニットテスト\n   - エージェントモード選択、プリセット解決、フェーズ実行順序のテスト\n\n9. **tests/unit/commands/list-presets.test.ts** (約50~80行)\n   - プリセット一覧表示のユニットテスト\n\n### 6.2 修正が必要な既存ファイル\n\n1. **src/main.ts** (1309行 → 200行以下)\n   - コマンドハンドラを削除し、新規モジュールからimport\n   - コマンドルーターとしての役割のみ残す\n\n2. **tests/unit/main-preset-resolution.test.ts** (220行)\n   - import文の修正\n\n3. **tests/unit/branch-validation.test.ts**\n   - import文の修正\n\n4. **tests/unit/repository-resolution.test.ts**\n   - import文の修正\n\n5. **tests/integration/workflow-init-cleanup.test.ts**\n   - import文の修正（必要に応じて）\n\n### 6.3 削除が必要なファイル\n\n- **なし** - ファイルの削除は不要\n\n---\n\n## 7. 詳細設計\n\n### 7.1 src/commands/init.ts\n\n#### 関数設計\n\n```typescript\n/**\n * Issue初期化コマンドハンドラ\n * @param issueUrl - GitHub Issue URL\n * @param customBranch - カスタムブランチ名（任意）\n */\nexport async function handleInitCommand(\n  issueUrl: string,\n  customBranch?: string\n): Promise<void> {\n  // 1. Issue URL解析\n  const issueInfo = parseIssueUrl(issueUrl);\n  \n  // 2. ローカルリポジトリパス解決\n  const repoPath = resolveLocalRepoPath(issueInfo.repo);\n  \n  // 3. ブランチ名解決\n  const branchName = resolveBranchName(issueInfo.issueNumber, customBranch);\n  \n  // 4. ブランチ名バリデーション\n  const validation = validateBranchName(branchName);\n  if (!validation.valid) {\n    throw new Error(`Invalid branch name: ${validation.reason}`);\n  }\n  \n  // 5. Git操作（ブランチ作成・チェックアウト）\n  // 6. メタデータ作成\n  // 7. Draft PR作成\n}\n\n/**\n * ブランチ名をバリデーション\n * @param branchName - バリデーション対象のブランチ名\n * @returns バリデーション結果\n */\nexport function validateBranchName(branchName: string): BranchValidationResult {\n  // Git命名規則チェック\n  // - 空白を含まない\n  // - 連続ドット(..)を含まない\n  // - 不正文字を含まない\n  // - /で始まらない・終わらない\n  // - .で終わらない\n}\n\n/**\n * ブランチ名を解決（カスタムまたはデフォルト）\n * @param issueNumber - Issue番号\n * @param customBranch - カスタムブランチ名（任意）\n * @returns 解決されたブランチ名\n */\nexport function resolveBranchName(\n  issueNumber: string,\n  customBranch?: string\n): string {\n  return customBranch || `ai-workflow/issue-${issueNumber}`;\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface BranchValidationResult {\n  valid: boolean;\n  reason?: string;\n}\n```\n\n### 7.2 src/commands/execute.ts\n\n#### 関数設計\n\n```typescript\n/**\n * フェーズ実行コマンドハンドラ\n * @param options - CLIオプション\n */\nexport async function handleExecuteCommand(options: any): Promise<void> {\n  // 1. メタデータ探索\n  const { repoRoot, metadataPath } = await findWorkflowMetadata(options.issue);\n  \n  // 2. メタデータ読み込み\n  const metadata = await loadMetadata(metadataPath);\n  \n  // 3. エージェントモード判定\n  const agentMode = options.agent || 'auto';\n  \n  // 4. プリセット解決\n  const phases = options.preset \n    ? getPresetPhases(options.preset)\n    : [options.phase];\n  \n  // 5. レジューム判定\n  if (canResumeWorkflow(metadata)) {\n    // Resume logic\n  }\n  \n  // 6. フェーズ順次実行\n  const summary = await executePhasesSequential(phases, metadata, options);\n  \n  // 7. 実行サマリー出力\n  return summary;\n}\n\n/**\n * プリセット名を正規化（後方互換性対応）\n * @param presetName - プリセット名\n * @returns 正規化されたプリセット名\n */\nexport function resolvePresetName(presetName: string): string {\n  const deprecatedPresets: Record<string, string> = {\n    'requirements-only': 'review-requirements',\n    'design-phase': 'review-design',\n    'implementation-phase': 'implementation',\n    'full-workflow': 'all'\n  };\n  \n  return deprecatedPresets[presetName] || presetName;\n}\n\n/**\n * プリセットのフェーズリストを取得\n * @param presetName - プリセット名\n * @returns フェーズ名の配列\n */\nexport function getPresetPhases(presetName: string): string[] {\n  // phase-dependencies.tsから取得\n}\n\n/**\n * ワークフロー再開可否を判定\n * @param metadata - メタデータ\n * @returns 再開可能な場合true\n */\nexport function canResumeWorkflow(metadata: WorkflowState): boolean {\n  // 未完了フェーズの存在を確認\n}\n\n/**\n * フェーズを順次実行\n * @param phases - フェーズ名の配列\n * @param metadata - メタデータ\n * @param options - CLIオプション\n * @returns 実行サマリー\n */\nexport async function executePhasesSequential(\n  phases: string[],\n  metadata: WorkflowState,\n  options: any\n): Promise<ExecutionSummary> {\n  const results: PhaseResultMap = {};\n  \n  for (const phaseName of phases) {\n    const phaseInstance = createPhaseInstance(phaseName, metadata, options);\n    const result = await phaseInstance.run(options);\n    results[phaseName] = result;\n  }\n  \n  return {\n    totalPhases: phases.length,\n    completedPhases: Object.values(results).filter(r => r.status === 'completed').length,\n    failedPhases: Object.values(results).filter(r => r.status === 'failed').length,\n    results\n  };\n}\n\n/**\n * フェーズインスタンスを作成\n * @param phaseName - フェーズ名\n * @param metadata - メタデータ\n * @param options - CLIオプション\n * @returns フェーズインスタンス\n */\nexport function createPhaseInstance(\n  phaseName: string,\n  metadata: WorkflowState,\n  options: any\n): BasePhase {\n  // 各フェーズクラスのインスタンスを生成\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface PhaseContext {\n  repoRoot: string;\n  metadataPath: string;\n  issueNumber: string;\n  agentMode: 'auto' | 'codex' | 'claude';\n}\n\nexport interface ExecutionSummary {\n  totalPhases: number;\n  completedPhases: number;\n  failedPhases: number;\n  results: PhaseResultMap;\n}\n\nexport interface PhaseResultMap {\n  [phaseName: string]: {\n    status: 'pending' | 'in_progress' | 'completed' | 'failed';\n    duration?: number;\n    error?: string;\n  };\n}\n```\n\n### 7.3 src/commands/list-presets.ts\n\n#### 関数設計\n\n```typescript\n/**\n * プリセット一覧表示コマンドハンドラ\n */\nexport function listPresets(): void {\n  console.log('\\n=== Available Presets ===\\n');\n  \n  const presets = getAllPresets();\n  for (const [name, phases] of Object.entries(presets)) {\n    console.log(`${name}:`);\n    console.log(`  Phases: ${phases.join(' → ')}`);\n  }\n  \n  console.log('\\n=== Deprecated Presets (use new names) ===\\n');\n  const deprecated = getDeprecatedPresets();\n  for (const [oldName, newName] of Object.entries(deprecated)) {\n    console.log(`${oldName} → ${newName} (use new name instead)`);\n  }\n}\n```\n\n### 7.4 src/commands/review.ts\n\n#### 関数設計\n\n```typescript\n/**\n * フェーズレビューコマンドハンドラ\n * @param options - CLIオプション\n */\nexport async function handleReviewCommand(options: any): Promise<void> {\n  // 1. メタデータ探索\n  const { metadataPath } = await findWorkflowMetadata(options.issue);\n  \n  // 2. メタデータ読み込み\n  const metadata = await loadMetadata(metadataPath);\n  \n  // 3. フェーズステータス取得\n  const phaseStatus = metadata.phases[options.phase];\n  \n  // 4. ステータス出力\n  console.log(`[OK] Phase ${options.phase} status: ${phaseStatus.status}`);\n}\n```\n\n### 7.5 src/core/repository-utils.ts\n\n#### 関数設計\n\n```typescript\n/**\n * GitHub Issue URLを解析\n * @param issueUrl - GitHub Issue URL\n * @returns Issue情報\n */\nexport function parseIssueUrl(issueUrl: string): IssueInfo {\n  const match = issueUrl.match(/github\\.com\\/([^/]+)\\/([^/]+)\\/issues\\/(\\d+)/);\n  if (!match) {\n    throw new Error(`Invalid GitHub Issue URL: ${issueUrl}`);\n  }\n  \n  return {\n    owner: match[1],\n    repo: match[2],\n    issueNumber: match[3]\n  };\n}\n\n/**\n * ローカルリポジトリパスを解決\n * @param repoName - リポジトリ名\n * @returns ローカルリポジトリパス\n */\nexport function resolveLocalRepoPath(repoName: string): string {\n  // 1. $REPOS_ROOT 検索\n  // 2. ~/TIELEC/development 検索\n  // 3. ~/projects 検索\n  // 4. ../ 検索\n}\n\n/**\n * ワークフローメタデータを探索\n * @param issueNumber - Issue番号\n * @returns リポジトリルートとメタデータパス\n */\nexport async function findWorkflowMetadata(\n  issueNumber: string\n): Promise<{ repoRoot: string; metadataPath: string }> {\n  // マルチリポジトリ環境でメタデータを探索\n}\n\n/**\n * リポジトリルートを取得\n * @returns リポジトリルート\n */\nexport async function getRepoRoot(): Promise<string> {\n  // Git repository root を取得\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface IssueInfo {\n  owner: string;\n  repo: string;\n  issueNumber: string;\n}\n```\n\n### 7.6 src/types/commands.ts\n\n#### 型定義\n\n```typescript\nexport interface IssueInfo {\n  owner: string;\n  repo: string;\n  issueNumber: string;\n}\n\nexport interface BranchValidationResult {\n  valid: boolean;\n  reason?: string;\n}\n\nexport interface PhaseContext {\n  repoRoot: string;\n  metadataPath: string;\n  issueNumber: string;\n  agentMode: 'auto' | 'codex' | 'claude';\n}\n\nexport interface ExecutionSummary {\n  totalPhases: number;\n  completedPhases: number;\n  failedPhases: number;\n  results: PhaseResultMap;\n}\n\nexport interface PhaseResultMap {\n  [phaseName: string]: {\n    status: 'pending' | 'in_progress' | 'completed' | 'failed';\n    duration?: number;\n    error?: string;\n  };\n}\n```\n\n### 7.7 src/main.ts（リファクタリング後）\n\n#### 構成\n\n```typescript\n#!/usr/bin/env node\nimport { Command } from 'commander';\nimport { handleInitCommand } from './commands/init.js';\nimport { handleExecuteCommand } from './commands/execute.js';\nimport { handleReviewCommand } from './commands/review.js';\nimport { listPresets } from './commands/list-presets.js';\n\n// Constants\nexport const PHASE_ORDER = [\n  'planning',\n  'requirements',\n  // ...\n];\n\n// Main CLI function\nexport async function runCli(): Promise<void> {\n  const program = new Command();\n  \n  // init command\n  program\n    .command('init')\n    .option('--issue-url <url>', 'GitHub Issue URL')\n    .option('--branch <name>', 'Custom branch name')\n    .action(async (options) => {\n      await handleInitCommand(options.issueUrl, options.branch);\n    });\n  \n  // execute command\n  program\n    .command('execute')\n    .option('--issue <number>', 'Issue number')\n    .option('--phase <name>', 'Phase name')\n    .option('--preset <name>', 'Preset name')\n    .option('--agent <mode>', 'Agent mode (auto/codex/claude)')\n    // ...\n    .action(async (options) => {\n      await handleExecuteCommand(options);\n    });\n  \n  // review command\n  program\n    .command('review')\n    .option('--phase <name>', 'Phase name')\n    .option('--issue <number>', 'Issue number')\n    .action(async (options) => {\n      await handleReviewCommand(options);\n    });\n  \n  // list-presets command\n  program\n    .command('list-presets')\n    .action(() => {\n      listPresets();\n    });\n  \n  await program.parseAsync(process.argv);\n}\n\n// Utility functions (remain in main.ts)\nexport function reportFatalError(error: Error): void {\n  console.error(`[ERROR] ${error.message}`);\n  process.exit(1);\n}\n\nexport function reportExecutionSummary(summary: ExecutionSummary): void {\n  console.log('\\n=== Execution Summary ===');\n  console.log(`Total Phases: ${summary.totalPhases}`);\n  console.log(`Completed: ${summary.completedPhases}`);\n  console.log(`Failed: ${summary.failedPhases}`);\n}\n\nexport function isValidPhaseName(phaseName: string): boolean {\n  return PHASE_ORDER.includes(phaseName) || phaseName === 'all';\n}\n```\n\n---\n\n## 8. セキュリティ考慮事項\n\n### 8.1 認証・認可\n\n- **GitHub認証**: 既存の `GITHUB_TOKEN` 環境変数を使用（変更なし）\n- **エージェント認証**: `CODEX_API_KEY`, `CLAUDE_CODE_CREDENTIALS_PATH` を使用（変更なし）\n- **トークンの保護**: リファクタリング後もトークンは環境変数経由でのみ取得し、ログに出力しない\n\n### 8.2 データ保護\n\n- **機密情報の漏洩防止**: エージェント実行時のログに認証情報が含まれないことを確認\n- **ファイルパーミッション**: メタデータファイル（`.ai-workflow/issue-*/metadata.json`）は既存の権限を維持\n\n### 8.3 セキュリティリスクと対策\n\n#### パストラバーサル攻撃\n\n**リスク**: `resolveLocalRepoPath()` や `findWorkflowMetadata()` で不正なパスが指定される可能性\n\n**対策**:\n- パス解決時に正規化（`path.resolve()`）を使用\n- シンボリックリンクのチェック（`fs.lstatSync()`）\n- 許可されたディレクトリ（`$REPOS_ROOT`, `~/TIELEC/development`, `~/projects`, `../`）のみ許可\n\n#### インジェクション攻撃\n\n**リスク**: ブランチ名やIssue URLに不正な文字が含まれる可能性\n\n**対策**:\n- `validateBranchName()` で厳格なバリデーション（Git命名規則チェック）\n- `parseIssueUrl()` で正規表現による厳格な検証\n- コマンドライン引数のサニタイゼーション（commander.jsの標準機能を使用）\n\n---\n\n## 9. 非機能要件への対応\n\n### 9.1 パフォーマンス\n\n#### ビルド時間\n\n- **現状**: TypeScriptコンパイル時間は約10秒\n- **リファクタリング後**: ファイル数増加（+6ファイル）により、コンパイル時間が約1~2秒増加する可能性\n- **対策**: 影響は軽微であり、許容範囲内\n\n#### CLI起動時間\n\n- **現状**: `node dist/index.js --help` の実行時間は約0.5秒\n- **リファクタリング後**: モジュール分割により、import数が増加するが、Node.jsの動的ロードにより影響は軽微\n- **測定**: リファクタリング前後で ±10% 以内を維持\n\n### 9.2 スケーラビリティ\n\n#### 新規コマンド追加\n\n- **リファクタリング後**: 新規コマンドは `src/commands/{command-name}.ts` として独立したモジュールで作成可能\n- **main.tsへの影響**: commander定義の追加のみ（10~20行程度）\n\n#### プリセット追加\n\n- **リファクタリング後**: `src/core/phase-dependencies.ts` のみ修正（コマンドモジュールへの影響なし）\n\n### 9.3 保守性\n\n#### コードの可読性\n\n- **リファクタリング後**: 各コマンドモジュールが250~500行程度に分割され、責務が明確化\n- **main.ts**: 200行以下に削減され、エントリーポイントの見通しが改善\n\n#### テスト容易性\n\n- **リファクタリング後**: 各コマンドモジュールが独立してテスト可能（export された関数を直接テスト）\n- **既存テスト**: import修正のみで既存テストが動作（リグレッション防止）\n\n---\n\n## 10. 実装の順序\n\n### 推奨実装順序\n\n#### フェーズ1: 共有モジュール作成（依存関係の基盤）\n\n1. **src/types/commands.ts** 作成\n   - 型定義を最優先で作成（他モジュールから参照されるため）\n   - 所要時間: 0.5h\n\n2. **src/core/repository-utils.ts** 作成\n   - `parseIssueUrl`, `resolveLocalRepoPath`, `findWorkflowMetadata` を移動\n   - 所要時間: 1h\n\n#### フェーズ2: コマンドモジュール作成（並行可能）\n\n3. **src/commands/init.ts** 作成\n   - `handleInitCommand`, `validateBranchName`, `resolveBranchName` を実装\n   - 所要時間: 1h\n\n4. **src/commands/execute.ts** 作成\n   - `handleExecuteCommand`, `executePhasesSequential`, `resolvePresetName` 等を実装\n   - 所要時間: 2h\n\n5. **src/commands/review.ts** 作成\n   - `handleReviewCommand` を実装\n   - 所要時間: 0.5h\n\n6. **src/commands/list-presets.ts** 作成\n   - `listPresets` を実装\n   - 所要時間: 0.5h\n\n#### フェーズ3: main.tsリファクタリング\n\n7. **src/main.ts** リファクタリング\n   - コマンドハンドラを削除し、新規モジュールからimport\n   - commander定義を更新\n   - 所要時間: 1h\n\n#### フェーズ4: テストコード作成・修正\n\n8. **既存テストのimport修正**\n   - `tests/unit/main-preset-resolution.test.ts`\n   - `tests/unit/branch-validation.test.ts`\n   - `tests/unit/repository-resolution.test.ts`\n   - 所要時間: 0.5h\n\n9. **新規ユニットテスト作成**\n   - `tests/unit/commands/init.test.ts`\n   - `tests/unit/commands/execute.test.ts`\n   - `tests/unit/commands/list-presets.test.ts`\n   - 所要時間: 1.5h\n\n#### フェーズ5: テスト実行・検証\n\n10. **ユニットテスト全件実行**\n    - `npm run test:unit` 実行\n    - 所要時間: 0.5h\n\n11. **統合テスト全件実行**\n    - `npm run test:integration` 実行\n    - 所要時間: 0.5h\n\n#### 依存関係\n\n```\nPhase 1 (types/commands.ts, repository-utils.ts)\n  ↓\nPhase 2 (init.ts, execute.ts, review.ts, list-presets.ts) [並行可能]\n  ↓\nPhase 3 (main.ts リファクタリング)\n  ↓\nPhase 4 (テストコード作成・修正)\n  ↓\nPhase 5 (テスト実行・検証)\n```\n\n---\n\n## 11. 品質ゲート確認\n\n### 必須要件チェックリスト\n\n- ✅ **実装戦略の判断根拠が明記されている**\n  - セクション2で「REFACTOR」戦略を選択し、4つの判断根拠を明記\n\n- ✅ **テスト戦略の判断根拠が明記されている**\n  - セクション3で「UNIT_INTEGRATION」戦略を選択し、3つの判断根拠を明記\n\n- ✅ **テストコード戦略の判断根拠が明記されている**\n  - セクション4で「BOTH_TEST」戦略を選択し、3つの判断根拠を明記\n\n- ✅ **既存コードへの影響範囲が分析されている**\n  - セクション5で既存ファイル5件の修正内容を詳細に分析\n\n- ✅ **変更が必要なファイルがリストアップされている**\n  - セクション6で新規作成ファイル9件、修正ファイル5件をリストアップ\n\n- ✅ **設計が実装可能である**\n  - セクション7で各モジュールの関数設計、データ構造、インターフェースを詳細に定義\n  - セクション10で実装順序と依存関係を明示\n\n---\n\n## 12. 補足情報\n\n### 12.1 既存プロジェクト構造との整合性\n\n本設計は、既存のプロジェクト構造（CLAUDE.md, ARCHITECTURE.md, README.md）と整合性を保ちます：\n\n- **既存のディレクトリ構造**: `src/core/`, `src/phases/`, `src/types/` を活用\n- **新規ディレクトリ**: `src/commands/` を追加（CLIコマンドモジュール用）\n- **既存のコーディング規約**: TypeScript strict mode、ESLint準拠、ES modules使用\n\n### 12.2 トレーサビリティ\n\n| 要件ID | 要件（requirements.md） | 設計セクション |\n|--------|------------------------|---------------|\n| FR-1.1 | initコマンドモジュールの作成 | 7.1 |\n| FR-1.2 | executeコマンドモジュールの作成 | 7.2 |\n| FR-1.3 | reviewコマンドモジュールの作成 | 7.4 |\n| FR-1.4 | list-presetsコマンドモジュールの作成 | 7.3 |\n| FR-2.1 | リポジトリユーティリティモジュールの作成 | 7.5 |\n| FR-2.2 | コマンド型定義モジュールの作成 | 7.6 |\n| FR-3.1 | main.ts をコマンドルーターに再構成 | 7.7 |\n| FR-4.1 | CLI インターフェースの互換性 | 7.7 |\n| FR-4.2 | エージェントモードの互換性 | 7.2 |\n\n---\n\n**設計書バージョン**: 1.0  \n**作成日**: 2025-01-20  \n**作成者**: AI Workflow Agent  \n**レビュー状態**: Pending Review"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":45873,"cache_read_input_tokens":12591,"cache_creation":{"ephemeral_5m_input_tokens":45873,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"7afadee8-ca2a-4778-85f9-6024072867a1","uuid":"b1bc99a0-6282-461d-8ff5-76fa9b687e66"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":174925,"duration_api_ms":177179,"num_turns":6,"result":"# 詳細設計書 - Issue #22\n\n**Issue番号**: #22  \n**タイトル**: [REFACTOR] CLI コマンド処理の分離 (main.ts リファクタリング)  \n**作成日**: 2025-01-20  \n**ステータス**: Design Phase\n\n---\n\n## 1. アーキテクチャ設計\n\n### 1.1 システム全体図\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     CLI Entry Point                         │\n│                    (src/main.ts)                            │\n│                    ~200 lines                               │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ - Commander definitions                              │  │\n│  │ - Command routing                                    │  │\n│  │ - Error handling (reportFatalError)                 │  │\n│  │ - Execution summary (reportExecutionSummary)        │  │\n│  │ - Phase validation (isValidPhaseName, PHASE_ORDER)  │  │\n│  └──────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n                            │\n        ┌───────────────────┼───────────────────┐\n        │                   │                   │\n        ▼                   ▼                   ▼\n┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐\n│ Init Command    │ │Execute Command  │ │List Presets     │\n│ Module          │ │ Module          │ │ Module          │\n│ (commands/      │ │ (commands/      │ │ (commands/      │\n│  init.ts)       │ │  execute.ts)    │ │  list-presets.  │\n│                 │ │                 │ │  ts)            │\n│ ~300 lines      │ │ ~500 lines      │ │ ~80 lines       │\n└─────────────────┘ └─────────────────┘ └─────────────────┘\n        │                   │                   │\n        └───────────────────┼───────────────────┘\n                            ▼\n        ┌───────────────────────────────────────┐\n        │   Shared Utilities & Types            │\n        │                                       │\n        │  ┌─────────────────────────────────┐ │\n        │  │ Repository Utils                │ │\n        │  │ (core/repository-utils.ts)      │ │\n        │  │ - parseIssueUrl                 │ │\n        │  │ - resolveLocalRepoPath          │ │\n        │  │ - findWorkflowMetadata          │ │\n        │  │ - getRepoRoot                   │ │\n        │  └─────────────────────────────────┘ │\n        │                                       │\n        │  ┌─────────────────────────────────┐ │\n        │  │ Command Types                   │ │\n        │  │ (types/commands.ts)             │ │\n        │  │ - PhaseContext                  │ │\n        │  │ - ExecutionSummary              │ │\n        │  │ - PhaseResultMap                │ │\n        │  │ - IssueInfo                     │ │\n        │  │ - BranchValidationResult        │ │\n        │  └─────────────────────────────────┘ │\n        └───────────────────────────────────────┘\n                            │\n        ┌───────────────────┴───────────────────┐\n        ▼                                       ▼\n┌─────────────────┐                 ┌─────────────────┐\n│ Existing Core   │                 │ Existing Phases │\n│ Modules         │                 │ Modules         │\n│ - MetadataManager│                │ - BasePhase     │\n│ - GitManager    │                 │ - PlanningPhase │\n│ - GitHubClient  │                 │ - ...           │\n│ - CodexAgent    │                 │                 │\n│ - ClaudeAgent   │                 │                 │\n└─────────────────┘                 └─────────────────┘\n```\n\n### 1.2 コンポーネント間の関係\n\n#### 依存関係フロー\n\n```\nmain.ts\n  ├── commands/init.ts\n  │     ├── core/repository-utils.ts\n  │     ├── types/commands.ts\n  │     ├── core/metadata-manager.ts\n  │     ├── core/git-manager.ts\n  │     └── core/github-client.ts\n  │\n  ├── commands/execute.ts\n  │     ├── core/repository-utils.ts\n  │     ├── types/commands.ts\n  │     ├── core/metadata-manager.ts\n  │     ├── core/git-manager.ts\n  │     ├── core/codex-agent-client.ts\n  │     ├── core/claude-agent-client.ts\n  │     ├── core/phase-dependencies.ts\n  │     └── phases/*.ts\n  │\n  ├── commands/list-presets.ts\n  │     └── core/phase-dependencies.ts\n  │\n  └── commands/review.ts (existing location)\n        ├── core/repository-utils.ts\n        ├── types/commands.ts\n        └── core/metadata-manager.ts\n```\n\n**循環依存の回避戦略**:\n- コマンドモジュール間は直接依存しない\n- 共有ロジックは `core/repository-utils.ts` と `types/commands.ts` に集約\n- すべてのコマンドモジュールは main.ts から一方向にimportされる\n\n### 1.3 データフロー\n\n#### init コマンド\n\n```\nUser Input (--issue-url, --branch)\n  ↓\nmain.ts (commander parsing)\n  ↓\ncommands/init.ts::handleInitCommand()\n  ↓\nrepository-utils.ts::parseIssueUrl()\n  → IssueInfo { owner, repo, issueNumber }\n  ↓\nrepository-utils.ts::resolveLocalRepoPath()\n  → Local repository path\n  ↓\ncommands/init.ts::validateBranchName()\n  → BranchValidationResult\n  ↓\ncommands/init.ts::resolveBranchName()\n  → Resolved branch name\n  ↓\nGitManager::createBranch()\n  ↓\nMetadataManager::createMetadata()\n  → .ai-workflow/issue-{num}/metadata.json\n  ↓\nGitHubClient::createDraftPR()\n  ↓\nConsole output (success message)\n```\n\n#### execute コマンド\n\n```\nUser Input (--issue, --phase, --preset, --agent)\n  ↓\nmain.ts (commander parsing + preset resolution)\n  ↓\ncommands/execute.ts::handleExecuteCommand()\n  ↓\nrepository-utils.ts::findWorkflowMetadata()\n  → { repoRoot, metadataPath }\n  ↓\nMetadataManager::loadMetadata()\n  → WorkflowState\n  ↓\ncommands/execute.ts::resolvePresetName()\n  → Canonical phase names\n  ↓\ncommands/execute.ts::canResumeWorkflow()\n  → Resume decision\n  ↓\ncommands/execute.ts::executePhasesSequential()\n  ↓\n  ┌─ Loop for each phase ─┐\n  │                        │\n  │ createPhaseInstance()  │\n  │   ↓                    │\n  │ BasePhase.run()        │\n  │   ├─ execute()         │\n  │   ├─ review()          │\n  │   └─ revise()          │\n  │   ↓                    │\n  │ MetadataManager.update()│\n  └────────────────────────┘\n  ↓\nExecutionSummary\n  ↓\nmain.ts::reportExecutionSummary()\n  ↓\nConsole output\n```\n\n---\n\n## 2. 実装戦略判断\n\n### 実装戦略: REFACTOR\n\n#### 判断根拠\n\n1. **既存コード改善が中心**\n   - `main.ts` (1309行) から責務を分離し、200行以下に削減することが主目的\n   - 新規機能の追加はなく、既存の4つのコマンド（init/execute/review/list-presets）を分離\n\n2. **機能追加なし**\n   - CLI インターフェース（コマンド、オプション）は変更しない\n   - 既存の動作を完全に維持（後方互換性100%）\n   - Issue要件でも「破壊的変更なし」が明示されている\n\n3. **構造改善**\n   - SOLID原則（単一責任原則）の適用が主目的\n   - コマンドごとの責務を明確化し、テスト容易性を向上\n   - 既存のテスト（ユニットテスト18件 + 統合テスト18件）を維持\n\n4. **拡張性向上**\n   - 将来的な新規コマンド追加を容易にする\n   - モジュール間の疎結合を実現\n\n---\n\n## 3. テスト戦略判断\n\n### テスト戦略: UNIT_INTEGRATION\n\n#### 判断根拠\n\n1. **ユニットテスト**\n   - モジュール分割後の各コマンドハンドラは独立してテスト可能\n   - 新規作成する各コマンドモジュールのロジックをユニットテストで検証\n   - 例:\n     - `commands/init.ts::validateBranchName()` のバリデーションロジック\n     - `commands/execute.ts::resolvePresetName()` のプリセット解決ロジック\n     - `commands/execute.ts::canResumeWorkflow()` のレジューム判定ロジック\n\n2. **統合テスト**\n   - 既存の統合テスト（18件）を再利用し、CLI全体の動作を検証\n   - エンドツーエンドの動作確認（CLI → コマンドモジュール → Core → Git/GitHub）\n   - 例:\n     - `tests/integration/workflow-init-cleanup.test.ts` - ワークフロー初期化とクリーンアップ\n     - `tests/integration/preset-execution.test.ts` - プリセット実行の統合テスト\n     - `tests/integration/multi-repo-workflow.test.ts` - マルチリポジトリワークフロー\n\n3. **BDD不要の理由**\n   - エンドユーザー向けの新機能追加ではなく、内部リファクタリングのため\n   - ユーザーストーリーベースのテストは既存の統合テストでカバー済み\n   - 既存のCLIインターフェースを変更しないため、新規のBDDシナリオは不要\n\n---\n\n## 4. テストコード戦略判断\n\n### テストコード戦略: BOTH_TEST\n\n#### 判断根拠\n\n1. **EXTEND_TEST（既存テストの拡張）**\n   - 既存のユニットテスト（`tests/unit/main-preset-resolution.test.ts` 等）のimport文を修正\n   - 既存テスト: 220行（main.tsのプライベート関数をテスト用に再現）\n   - 対応方針: モジュール分離後は正式なexportされた関数をテストするよう変更\n   - 例:\n     ```typescript\n     // Before (main-preset-resolution.test.ts)\n     // main.tsのプライベート関数を再現してテスト\n     \n     // After\n     import { resolvePresetName } from '../../src/commands/execute.js';\n     // 正式なexport関数をテスト\n     ```\n\n2. **CREATE_TEST（新規テスト作成）**\n   - 新規コマンドモジュールのユニットテストを作成\n   - 作成するテストファイル:\n     - `tests/unit/commands/init.test.ts` - 初期化コマンドのロジックテスト\n     - `tests/unit/commands/execute.test.ts` - 実行コマンドのロジックテスト（エージェント選択、プリセット解決等）\n     - `tests/unit/commands/list-presets.test.ts` - プリセット一覧表示のロジックテスト\n\n3. **BOTH適用の理由**\n   - 既存テストは互換性維持のために拡張が必要（import修正、テストロジック更新）\n   - 新規モジュールは独立したテストカバレッジが必要（モジュール単位のテスト）\n   - 両方を実施することで、リグレッション防止と新規コード品質保証の両立を実現\n\n---\n\n## 5. 影響範囲分析\n\n### 5.1 既存コードへの影響\n\n#### 変更が必要な既存ファイル\n\n1. **src/main.ts** (1309行 → 200行以下に削減)\n   - コマンドルーターとしての役割のみ残す\n   - 削除する関数:\n     - `handleInitCommand` (229行: L229-L450)\n     - `handleExecuteCommand` (346行: L452-L798)\n     - `handleReviewCommand` (18行: L800-L817)\n     - `listPresets` (26行: L1201-L1225)\n   - 移動する関数:\n     - `parseIssueUrl` → `core/repository-utils.ts`\n     - `resolveLocalRepoPath` → `core/repository-utils.ts`\n     - `findWorkflowMetadata` → `core/repository-utils.ts`\n     - `validateBranchName` → `commands/init.ts`\n     - `resolveBranchName` → `commands/init.ts`\n     - `resolvePresetName` → `commands/execute.ts`\n     - `getPresetPhases` → `commands/execute.ts`\n     - `canResumeWorkflow` → `commands/execute.ts`\n     - `executePhasesSequential` → `commands/execute.ts`\n     - `createPhaseInstance` → `commands/execute.ts`\n   - 残す関数:\n     - `runCli()` - CLIエントリーポイント\n     - `reportFatalError()` - エラーハンドリング\n     - `reportExecutionSummary()` - 実行サマリー表示\n     - `isValidPhaseName()` - フェーズ名バリデーション\n     - `PHASE_ORDER` 定数\n\n2. **tests/unit/main-preset-resolution.test.ts** (220行)\n   - import文の修正: `resolvePresetName` を `src/commands/execute.ts` からimport\n   - テストロジックの修正: 再現コードを削除し、正式なexportされた関数を使用\n\n3. **tests/integration/workflow-init-cleanup.test.ts**\n   - import文の修正: 必要に応じて `src/commands/init.ts` からimport\n   - テストケース自体は変更不要（動作の互換性維持）\n\n4. **tests/unit/repository-resolution.test.ts**\n   - import文の修正: `parseIssueUrl`, `resolveLocalRepoPath`, `findWorkflowMetadata` を `core/repository-utils.ts` からimport\n\n5. **tests/unit/branch-validation.test.ts**\n   - import文の修正: `validateBranchName`, `resolveBranchName` を `commands/init.ts` からimport\n\n### 5.2 依存関係の変更\n\n#### 新規依存の追加\n\n- **なし** - 既存の依存関係（commander, fs-extra, simple-git等）のみ使用\n\n#### 既存依存の変更\n\n- **なし** - 依存ライブラリのバージョン変更は不要\n\n### 5.3 マイグレーション要否\n\n#### データベーススキーマ変更\n\n- **なし**\n\n#### 設定ファイル変更\n\n- **なし** - package.json, tsconfig.jsonの変更不要\n- **ビルドスクリプト**: 既存のビルドスクリプト（`npm run build`）で自動的に新規ファイルをコンパイル\n\n#### 環境変数変更\n\n- **なし** - 既存の環境変数（GITHUB_TOKEN, CODEX_API_KEY等）をそのまま使用\n\n---\n\n## 6. 変更・追加ファイルリスト\n\n### 6.1 新規作成ファイル\n\n#### コマンドモジュール\n\n1. **src/commands/init.ts** (約250~300行)\n   - `handleInitCommand()` 関数\n   - `validateBranchName()` 関数\n   - `resolveBranchName()` 関数\n\n2. **src/commands/execute.ts** (約450~500行)\n   - `handleExecuteCommand()` 関数\n   - `executePhasesSequential()` 関数\n   - `executePhasesFrom()` 関数\n   - `createPhaseInstance()` 関数\n   - `resolvePresetName()` 関数\n   - `getPresetPhases()` 関数\n   - `canResumeWorkflow()` 関数\n   - `loadExternalDocuments()` 関数\n   - `resetMetadata()` 関数\n\n3. **src/commands/list-presets.ts** (約50~80行)\n   - `listPresets()` 関数\n\n4. **src/commands/review.ts** (約50行)\n   - `handleReviewCommand()` 関数（現在はmain.tsに存在）\n\n#### 共有モジュール\n\n5. **src/core/repository-utils.ts** (約200行)\n   - `parseIssueUrl()` 関数（main.tsから移動）\n   - `resolveLocalRepoPath()` 関数（main.tsから移動）\n   - `findWorkflowMetadata()` 関数（main.tsから移動）\n   - `getRepoRoot()` 関数（新規export）\n\n6. **src/types/commands.ts** (約100行)\n   - `PhaseContext` 型定義\n   - `ExecutionSummary` 型定義\n   - `PhaseResultMap` 型定義\n   - `IssueInfo` 型定義（main.tsから移動）\n   - `BranchValidationResult` 型定義\n\n#### テストファイル\n\n7. **tests/unit/commands/init.test.ts** (約150~200行)\n   - 初期化コマンドのユニットテスト\n   - ブランチ名バリデーション、Issue URL解析、リポジトリ解決のテスト\n\n8. **tests/unit/commands/execute.test.ts** (約200~250行)\n   - 実行コマンドのユニットテスト\n   - エージェントモード選択、プリセット解決、フェーズ実行順序のテスト\n\n9. **tests/unit/commands/list-presets.test.ts** (約50~80行)\n   - プリセット一覧表示のユニットテスト\n\n### 6.2 修正が必要な既存ファイル\n\n1. **src/main.ts** (1309行 → 200行以下)\n   - コマンドハンドラを削除し、新規モジュールからimport\n   - コマンドルーターとしての役割のみ残す\n\n2. **tests/unit/main-preset-resolution.test.ts** (220行)\n   - import文の修正\n\n3. **tests/unit/branch-validation.test.ts**\n   - import文の修正\n\n4. **tests/unit/repository-resolution.test.ts**\n   - import文の修正\n\n5. **tests/integration/workflow-init-cleanup.test.ts**\n   - import文の修正（必要に応じて）\n\n### 6.3 削除が必要なファイル\n\n- **なし** - ファイルの削除は不要\n\n---\n\n## 7. 詳細設計\n\n### 7.1 src/commands/init.ts\n\n#### 関数設計\n\n```typescript\n/**\n * Issue初期化コマンドハンドラ\n * @param issueUrl - GitHub Issue URL\n * @param customBranch - カスタムブランチ名（任意）\n */\nexport async function handleInitCommand(\n  issueUrl: string,\n  customBranch?: string\n): Promise<void> {\n  // 1. Issue URL解析\n  const issueInfo = parseIssueUrl(issueUrl);\n  \n  // 2. ローカルリポジトリパス解決\n  const repoPath = resolveLocalRepoPath(issueInfo.repo);\n  \n  // 3. ブランチ名解決\n  const branchName = resolveBranchName(issueInfo.issueNumber, customBranch);\n  \n  // 4. ブランチ名バリデーション\n  const validation = validateBranchName(branchName);\n  if (!validation.valid) {\n    throw new Error(`Invalid branch name: ${validation.reason}`);\n  }\n  \n  // 5. Git操作（ブランチ作成・チェックアウト）\n  // 6. メタデータ作成\n  // 7. Draft PR作成\n}\n\n/**\n * ブランチ名をバリデーション\n * @param branchName - バリデーション対象のブランチ名\n * @returns バリデーション結果\n */\nexport function validateBranchName(branchName: string): BranchValidationResult {\n  // Git命名規則チェック\n  // - 空白を含まない\n  // - 連続ドット(..)を含まない\n  // - 不正文字を含まない\n  // - /で始まらない・終わらない\n  // - .で終わらない\n}\n\n/**\n * ブランチ名を解決（カスタムまたはデフォルト）\n * @param issueNumber - Issue番号\n * @param customBranch - カスタムブランチ名（任意）\n * @returns 解決されたブランチ名\n */\nexport function resolveBranchName(\n  issueNumber: string,\n  customBranch?: string\n): string {\n  return customBranch || `ai-workflow/issue-${issueNumber}`;\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface BranchValidationResult {\n  valid: boolean;\n  reason?: string;\n}\n```\n\n### 7.2 src/commands/execute.ts\n\n#### 関数設計\n\n```typescript\n/**\n * フェーズ実行コマンドハンドラ\n * @param options - CLIオプション\n */\nexport async function handleExecuteCommand(options: any): Promise<void> {\n  // 1. メタデータ探索\n  const { repoRoot, metadataPath } = await findWorkflowMetadata(options.issue);\n  \n  // 2. メタデータ読み込み\n  const metadata = await loadMetadata(metadataPath);\n  \n  // 3. エージェントモード判定\n  const agentMode = options.agent || 'auto';\n  \n  // 4. プリセット解決\n  const phases = options.preset \n    ? getPresetPhases(options.preset)\n    : [options.phase];\n  \n  // 5. レジューム判定\n  if (canResumeWorkflow(metadata)) {\n    // Resume logic\n  }\n  \n  // 6. フェーズ順次実行\n  const summary = await executePhasesSequential(phases, metadata, options);\n  \n  // 7. 実行サマリー出力\n  return summary;\n}\n\n/**\n * プリセット名を正規化（後方互換性対応）\n * @param presetName - プリセット名\n * @returns 正規化されたプリセット名\n */\nexport function resolvePresetName(presetName: string): string {\n  const deprecatedPresets: Record<string, string> = {\n    'requirements-only': 'review-requirements',\n    'design-phase': 'review-design',\n    'implementation-phase': 'implementation',\n    'full-workflow': 'all'\n  };\n  \n  return deprecatedPresets[presetName] || presetName;\n}\n\n/**\n * プリセットのフェーズリストを取得\n * @param presetName - プリセット名\n * @returns フェーズ名の配列\n */\nexport function getPresetPhases(presetName: string): string[] {\n  // phase-dependencies.tsから取得\n}\n\n/**\n * ワークフロー再開可否を判定\n * @param metadata - メタデータ\n * @returns 再開可能な場合true\n */\nexport function canResumeWorkflow(metadata: WorkflowState): boolean {\n  // 未完了フェーズの存在を確認\n}\n\n/**\n * フェーズを順次実行\n * @param phases - フェーズ名の配列\n * @param metadata - メタデータ\n * @param options - CLIオプション\n * @returns 実行サマリー\n */\nexport async function executePhasesSequential(\n  phases: string[],\n  metadata: WorkflowState,\n  options: any\n): Promise<ExecutionSummary> {\n  const results: PhaseResultMap = {};\n  \n  for (const phaseName of phases) {\n    const phaseInstance = createPhaseInstance(phaseName, metadata, options);\n    const result = await phaseInstance.run(options);\n    results[phaseName] = result;\n  }\n  \n  return {\n    totalPhases: phases.length,\n    completedPhases: Object.values(results).filter(r => r.status === 'completed').length,\n    failedPhases: Object.values(results).filter(r => r.status === 'failed').length,\n    results\n  };\n}\n\n/**\n * フェーズインスタンスを作成\n * @param phaseName - フェーズ名\n * @param metadata - メタデータ\n * @param options - CLIオプション\n * @returns フェーズインスタンス\n */\nexport function createPhaseInstance(\n  phaseName: string,\n  metadata: WorkflowState,\n  options: any\n): BasePhase {\n  // 各フェーズクラスのインスタンスを生成\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface PhaseContext {\n  repoRoot: string;\n  metadataPath: string;\n  issueNumber: string;\n  agentMode: 'auto' | 'codex' | 'claude';\n}\n\nexport interface ExecutionSummary {\n  totalPhases: number;\n  completedPhases: number;\n  failedPhases: number;\n  results: PhaseResultMap;\n}\n\nexport interface PhaseResultMap {\n  [phaseName: string]: {\n    status: 'pending' | 'in_progress' | 'completed' | 'failed';\n    duration?: number;\n    error?: string;\n  };\n}\n```\n\n### 7.3 src/commands/list-presets.ts\n\n#### 関数設計\n\n```typescript\n/**\n * プリセット一覧表示コマンドハンドラ\n */\nexport function listPresets(): void {\n  console.log('\\n=== Available Presets ===\\n');\n  \n  const presets = getAllPresets();\n  for (const [name, phases] of Object.entries(presets)) {\n    console.log(`${name}:`);\n    console.log(`  Phases: ${phases.join(' → ')}`);\n  }\n  \n  console.log('\\n=== Deprecated Presets (use new names) ===\\n');\n  const deprecated = getDeprecatedPresets();\n  for (const [oldName, newName] of Object.entries(deprecated)) {\n    console.log(`${oldName} → ${newName} (use new name instead)`);\n  }\n}\n```\n\n### 7.4 src/commands/review.ts\n\n#### 関数設計\n\n```typescript\n/**\n * フェーズレビューコマンドハンドラ\n * @param options - CLIオプション\n */\nexport async function handleReviewCommand(options: any): Promise<void> {\n  // 1. メタデータ探索\n  const { metadataPath } = await findWorkflowMetadata(options.issue);\n  \n  // 2. メタデータ読み込み\n  const metadata = await loadMetadata(metadataPath);\n  \n  // 3. フェーズステータス取得\n  const phaseStatus = metadata.phases[options.phase];\n  \n  // 4. ステータス出力\n  console.log(`[OK] Phase ${options.phase} status: ${phaseStatus.status}`);\n}\n```\n\n### 7.5 src/core/repository-utils.ts\n\n#### 関数設計\n\n```typescript\n/**\n * GitHub Issue URLを解析\n * @param issueUrl - GitHub Issue URL\n * @returns Issue情報\n */\nexport function parseIssueUrl(issueUrl: string): IssueInfo {\n  const match = issueUrl.match(/github\\.com\\/([^/]+)\\/([^/]+)\\/issues\\/(\\d+)/);\n  if (!match) {\n    throw new Error(`Invalid GitHub Issue URL: ${issueUrl}`);\n  }\n  \n  return {\n    owner: match[1],\n    repo: match[2],\n    issueNumber: match[3]\n  };\n}\n\n/**\n * ローカルリポジトリパスを解決\n * @param repoName - リポジトリ名\n * @returns ローカルリポジトリパス\n */\nexport function resolveLocalRepoPath(repoName: string): string {\n  // 1. $REPOS_ROOT 検索\n  // 2. ~/TIELEC/development 検索\n  // 3. ~/projects 検索\n  // 4. ../ 検索\n}\n\n/**\n * ワークフローメタデータを探索\n * @param issueNumber - Issue番号\n * @returns リポジトリルートとメタデータパス\n */\nexport async function findWorkflowMetadata(\n  issueNumber: string\n): Promise<{ repoRoot: string; metadataPath: string }> {\n  // マルチリポジトリ環境でメタデータを探索\n}\n\n/**\n * リポジトリルートを取得\n * @returns リポジトリルート\n */\nexport async function getRepoRoot(): Promise<string> {\n  // Git repository root を取得\n}\n```\n\n#### データ構造\n\n```typescript\n// src/types/commands.ts\n\nexport interface IssueInfo {\n  owner: string;\n  repo: string;\n  issueNumber: string;\n}\n```\n\n### 7.6 src/types/commands.ts\n\n#### 型定義\n\n```typescript\nexport interface IssueInfo {\n  owner: string;\n  repo: string;\n  issueNumber: string;\n}\n\nexport interface BranchValidationResult {\n  valid: boolean;\n  reason?: string;\n}\n\nexport interface PhaseContext {\n  repoRoot: string;\n  metadataPath: string;\n  issueNumber: string;\n  agentMode: 'auto' | 'codex' | 'claude';\n}\n\nexport interface ExecutionSummary {\n  totalPhases: number;\n  completedPhases: number;\n  failedPhases: number;\n  results: PhaseResultMap;\n}\n\nexport interface PhaseResultMap {\n  [phaseName: string]: {\n    status: 'pending' | 'in_progress' | 'completed' | 'failed';\n    duration?: number;\n    error?: string;\n  };\n}\n```\n\n### 7.7 src/main.ts（リファクタリング後）\n\n#### 構成\n\n```typescript\n#!/usr/bin/env node\nimport { Command } from 'commander';\nimport { handleInitCommand } from './commands/init.js';\nimport { handleExecuteCommand } from './commands/execute.js';\nimport { handleReviewCommand } from './commands/review.js';\nimport { listPresets } from './commands/list-presets.js';\n\n// Constants\nexport const PHASE_ORDER = [\n  'planning',\n  'requirements',\n  // ...\n];\n\n// Main CLI function\nexport async function runCli(): Promise<void> {\n  const program = new Command();\n  \n  // init command\n  program\n    .command('init')\n    .option('--issue-url <url>', 'GitHub Issue URL')\n    .option('--branch <name>', 'Custom branch name')\n    .action(async (options) => {\n      await handleInitCommand(options.issueUrl, options.branch);\n    });\n  \n  // execute command\n  program\n    .command('execute')\n    .option('--issue <number>', 'Issue number')\n    .option('--phase <name>', 'Phase name')\n    .option('--preset <name>', 'Preset name')\n    .option('--agent <mode>', 'Agent mode (auto/codex/claude)')\n    // ...\n    .action(async (options) => {\n      await handleExecuteCommand(options);\n    });\n  \n  // review command\n  program\n    .command('review')\n    .option('--phase <name>', 'Phase name')\n    .option('--issue <number>', 'Issue number')\n    .action(async (options) => {\n      await handleReviewCommand(options);\n    });\n  \n  // list-presets command\n  program\n    .command('list-presets')\n    .action(() => {\n      listPresets();\n    });\n  \n  await program.parseAsync(process.argv);\n}\n\n// Utility functions (remain in main.ts)\nexport function reportFatalError(error: Error): void {\n  console.error(`[ERROR] ${error.message}`);\n  process.exit(1);\n}\n\nexport function reportExecutionSummary(summary: ExecutionSummary): void {\n  console.log('\\n=== Execution Summary ===');\n  console.log(`Total Phases: ${summary.totalPhases}`);\n  console.log(`Completed: ${summary.completedPhases}`);\n  console.log(`Failed: ${summary.failedPhases}`);\n}\n\nexport function isValidPhaseName(phaseName: string): boolean {\n  return PHASE_ORDER.includes(phaseName) || phaseName === 'all';\n}\n```\n\n---\n\n## 8. セキュリティ考慮事項\n\n### 8.1 認証・認可\n\n- **GitHub認証**: 既存の `GITHUB_TOKEN` 環境変数を使用（変更なし）\n- **エージェント認証**: `CODEX_API_KEY`, `CLAUDE_CODE_CREDENTIALS_PATH` を使用（変更なし）\n- **トークンの保護**: リファクタリング後もトークンは環境変数経由でのみ取得し、ログに出力しない\n\n### 8.2 データ保護\n\n- **機密情報の漏洩防止**: エージェント実行時のログに認証情報が含まれないことを確認\n- **ファイルパーミッション**: メタデータファイル（`.ai-workflow/issue-*/metadata.json`）は既存の権限を維持\n\n### 8.3 セキュリティリスクと対策\n\n#### パストラバーサル攻撃\n\n**リスク**: `resolveLocalRepoPath()` や `findWorkflowMetadata()` で不正なパスが指定される可能性\n\n**対策**:\n- パス解決時に正規化（`path.resolve()`）を使用\n- シンボリックリンクのチェック（`fs.lstatSync()`）\n- 許可されたディレクトリ（`$REPOS_ROOT`, `~/TIELEC/development`, `~/projects`, `../`）のみ許可\n\n#### インジェクション攻撃\n\n**リスク**: ブランチ名やIssue URLに不正な文字が含まれる可能性\n\n**対策**:\n- `validateBranchName()` で厳格なバリデーション（Git命名規則チェック）\n- `parseIssueUrl()` で正規表現による厳格な検証\n- コマンドライン引数のサニタイゼーション（commander.jsの標準機能を使用）\n\n---\n\n## 9. 非機能要件への対応\n\n### 9.1 パフォーマンス\n\n#### ビルド時間\n\n- **現状**: TypeScriptコンパイル時間は約10秒\n- **リファクタリング後**: ファイル数増加（+6ファイル）により、コンパイル時間が約1~2秒増加する可能性\n- **対策**: 影響は軽微であり、許容範囲内\n\n#### CLI起動時間\n\n- **現状**: `node dist/index.js --help` の実行時間は約0.5秒\n- **リファクタリング後**: モジュール分割により、import数が増加するが、Node.jsの動的ロードにより影響は軽微\n- **測定**: リファクタリング前後で ±10% 以内を維持\n\n### 9.2 スケーラビリティ\n\n#### 新規コマンド追加\n\n- **リファクタリング後**: 新規コマンドは `src/commands/{command-name}.ts` として独立したモジュールで作成可能\n- **main.tsへの影響**: commander定義の追加のみ（10~20行程度）\n\n#### プリセット追加\n\n- **リファクタリング後**: `src/core/phase-dependencies.ts` のみ修正（コマンドモジュールへの影響なし）\n\n### 9.3 保守性\n\n#### コードの可読性\n\n- **リファクタリング後**: 各コマンドモジュールが250~500行程度に分割され、責務が明確化\n- **main.ts**: 200行以下に削減され、エントリーポイントの見通しが改善\n\n#### テスト容易性\n\n- **リファクタリング後**: 各コマンドモジュールが独立してテスト可能（export された関数を直接テスト）\n- **既存テスト**: import修正のみで既存テストが動作（リグレッション防止）\n\n---\n\n## 10. 実装の順序\n\n### 推奨実装順序\n\n#### フェーズ1: 共有モジュール作成（依存関係の基盤）\n\n1. **src/types/commands.ts** 作成\n   - 型定義を最優先で作成（他モジュールから参照されるため）\n   - 所要時間: 0.5h\n\n2. **src/core/repository-utils.ts** 作成\n   - `parseIssueUrl`, `resolveLocalRepoPath`, `findWorkflowMetadata` を移動\n   - 所要時間: 1h\n\n#### フェーズ2: コマンドモジュール作成（並行可能）\n\n3. **src/commands/init.ts** 作成\n   - `handleInitCommand`, `validateBranchName`, `resolveBranchName` を実装\n   - 所要時間: 1h\n\n4. **src/commands/execute.ts** 作成\n   - `handleExecuteCommand`, `executePhasesSequential`, `resolvePresetName` 等を実装\n   - 所要時間: 2h\n\n5. **src/commands/review.ts** 作成\n   - `handleReviewCommand` を実装\n   - 所要時間: 0.5h\n\n6. **src/commands/list-presets.ts** 作成\n   - `listPresets` を実装\n   - 所要時間: 0.5h\n\n#### フェーズ3: main.tsリファクタリング\n\n7. **src/main.ts** リファクタリング\n   - コマンドハンドラを削除し、新規モジュールからimport\n   - commander定義を更新\n   - 所要時間: 1h\n\n#### フェーズ4: テストコード作成・修正\n\n8. **既存テストのimport修正**\n   - `tests/unit/main-preset-resolution.test.ts`\n   - `tests/unit/branch-validation.test.ts`\n   - `tests/unit/repository-resolution.test.ts`\n   - 所要時間: 0.5h\n\n9. **新規ユニットテスト作成**\n   - `tests/unit/commands/init.test.ts`\n   - `tests/unit/commands/execute.test.ts`\n   - `tests/unit/commands/list-presets.test.ts`\n   - 所要時間: 1.5h\n\n#### フェーズ5: テスト実行・検証\n\n10. **ユニットテスト全件実行**\n    - `npm run test:unit` 実行\n    - 所要時間: 0.5h\n\n11. **統合テスト全件実行**\n    - `npm run test:integration` 実行\n    - 所要時間: 0.5h\n\n#### 依存関係\n\n```\nPhase 1 (types/commands.ts, repository-utils.ts)\n  ↓\nPhase 2 (init.ts, execute.ts, review.ts, list-presets.ts) [並行可能]\n  ↓\nPhase 3 (main.ts リファクタリング)\n  ↓\nPhase 4 (テストコード作成・修正)\n  ↓\nPhase 5 (テスト実行・検証)\n```\n\n---\n\n## 11. 品質ゲート確認\n\n### 必須要件チェックリスト\n\n- ✅ **実装戦略の判断根拠が明記されている**\n  - セクション2で「REFACTOR」戦略を選択し、4つの判断根拠を明記\n\n- ✅ **テスト戦略の判断根拠が明記されている**\n  - セクション3で「UNIT_INTEGRATION」戦略を選択し、3つの判断根拠を明記\n\n- ✅ **テストコード戦略の判断根拠が明記されている**\n  - セクション4で「BOTH_TEST」戦略を選択し、3つの判断根拠を明記\n\n- ✅ **既存コードへの影響範囲が分析されている**\n  - セクション5で既存ファイル5件の修正内容を詳細に分析\n\n- ✅ **変更が必要なファイルがリストアップされている**\n  - セクション6で新規作成ファイル9件、修正ファイル5件をリストアップ\n\n- ✅ **設計が実装可能である**\n  - セクション7で各モジュールの関数設計、データ構造、インターフェースを詳細に定義\n  - セクション10で実装順序と依存関係を明示\n\n---\n\n## 12. 補足情報\n\n### 12.1 既存プロジェクト構造との整合性\n\n本設計は、既存のプロジェクト構造（CLAUDE.md, ARCHITECTURE.md, README.md）と整合性を保ちます：\n\n- **既存のディレクトリ構造**: `src/core/`, `src/phases/`, `src/types/` を活用\n- **新規ディレクトリ**: `src/commands/` を追加（CLIコマンドモジュール用）\n- **既存のコーディング規約**: TypeScript strict mode、ESLint準拠、ES modules使用\n\n### 12.2 トレーサビリティ\n\n| 要件ID | 要件（requirements.md） | 設計セクション |\n|--------|------------------------|---------------|\n| FR-1.1 | initコマンドモジュールの作成 | 7.1 |\n| FR-1.2 | executeコマンドモジュールの作成 | 7.2 |\n| FR-1.3 | reviewコマンドモジュールの作成 | 7.4 |\n| FR-1.4 | list-presetsコマンドモジュールの作成 | 7.3 |\n| FR-2.1 | リポジトリユーティリティモジュールの作成 | 7.5 |\n| FR-2.2 | コマンド型定義モジュールの作成 | 7.6 |\n| FR-3.1 | main.ts をコマンドルーターに再構成 | 7.7 |\n| FR-4.1 | CLI インターフェースの互換性 | 7.7 |\n| FR-4.2 | エージェントモードの互換性 | 7.2 |\n\n---\n\n**設計書バージョン**: 1.0  \n**作成日**: 2025-01-20  \n**作成者**: AI Workflow Agent  \n**レビュー状態**: Pending Review","session_id":"7afadee8-ca2a-4778-85f9-6024072867a1","total_cost_usd":0.35895105,"usage":{"input_tokens":2,"cache_creation_input_tokens":45873,"cache_read_input_tokens":12591,"output_tokens":12130,"server_tool_use":{"web_search_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":45873}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":624,"outputTokens":114,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.001194,"contextWindow":200000},"claude-sonnet-4-5-20250929":{"inputTokens":2,"outputTokens":12130,"cacheReadInputTokens":12591,"cacheCreationInputTokens":45873,"webSearchRequests":0,"costUSD":0.35775705,"contextWindow":200000}},"permission_denials":[],"uuid":"dd94ff07-3182-420e-879f-4e2a7937bac9"}