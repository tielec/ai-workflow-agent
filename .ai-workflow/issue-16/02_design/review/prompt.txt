# 詳細設計フェーズ - レビュープロンプト

## レビュー対象
設計書をクリティカルシンキングの観点からレビューしてください。

### 設計書
@.ai-workflow/issue-16/02_design/output/design.md

### 要件定義書（参考）
@.ai-workflow/issue-16/01_requirements/output/requirements.md

### GitHub Issue情報（参考）
## Issue概要

- **Issue番号**: #16
- **タイトル**: Gitコミットメッセージの改善（メタデータ初期化、ログクリーンアップ）
- **状態**: open
- **URL**: https://github.com/tielec/ai-workflow-agent/issues/16
- **ラベル**: なし

### 本文

## 概要

現在、以下のGitコミットメッセージが不適切な状態になっています：

1. **メタデータ初期化時のコミットメッセージ**（最も優先度高）
2. **ログクリーンアップ時のコミットメッセージ**
3. **Planning Phase（Phase 0）のログが削除されない**
4. **Evaluation Phase完了後のログクリーンアップが未実装**

## 問題1: メタデータ初期化時のコミットメッセージが不適切

### 現在の動作

`src/main.ts:390` で、メタデータの初回コミット時に：

```typescript
const commitResult = await gitManager.commitPhaseOutput('planning', 'completed', 'N/A');
```

このため、コミットメッセージは以下のようになります：

```
[ai-workflow] Phase 1 (planning) - completed

Issue: #123
Phase: 1 (planning)
Status: completed
Review: N/A

Auto-generated by AI Workflow
```

**問題点**: ワークフローの初期化であって、Planning Phaseの完了ではない。

### 提案する改善内容

`src/core/git-manager.ts` に新しいメソッドを追加：

```typescript
/**
 * ワークフロー初期化用のコミットを作成
 */
public async commitWorkflowInit(
  issueNumber: number,
  branchName: string
): Promise<CommitResult> {
  const changedFiles = await this.getChangedFiles();
  const targetFiles = this.filterPhaseFiles(changedFiles, issueNumber.toString());

  if (targetFiles.length === 0) {
    console.warn('[WARNING] No files to commit for initialization');
    return {
      success: true,
      commit_hash: null,
      files_committed: [],
    };
  }

  await this.git.add(targetFiles);
  await this.ensureGitConfig();

  const message = this.createInitCommitMessage(issueNumber, branchName);

  try {
    const commitResponse = await this.git.commit(message, targetFiles, {
      '--no-verify': null,
    });

    console.info(`[INFO] Initialization commit created: ${commitResponse.commit ?? 'unknown'}`);

    return {
      success: true,
      commit_hash: commitResponse.commit ?? null,
      files_committed: targetFiles,
    };
  } catch (error) {
    console.error(`[ERROR] Initialization commit failed: ${(error as Error).message}`);
    return {
      success: false,
      commit_hash: null,
      files_committed: targetFiles,
      error: `Initialization commit failed: ${(error as Error).message}`,
    };
  }
}

/**
 * ワークフロー初期化用のコミットメッセージを生成
 */
private createInitCommitMessage(
  issueNumber: number,
  branchName: string
): string {
  return [
    `[ai-workflow] Initialize workflow for issue #${issueNumber}`,
    '',
    `Issue: #${issueNumber}`,
    `Action: Create workflow metadata and directory structure`,
    `Branch: ${branchName}`,
    '',
    'Auto-generated by AI Workflow',
  ].join('\n');
}
```

`src/main.ts:389-393` を修正：

```typescript
// 変更前:
const commitResult = await gitManager.commitPhaseOutput('planning', 'completed', 'N/A');

// 変更後:
const commitResult = await gitManager.commitWorkflowInit(issueNumber, branchName);
```

## 問題2: ログクリーンアップ時のコミットメッセージが不適切

### 現在の動作

Report Phase（Phase 8）完了時、ログクリーンアップのコミットメッセージは：

```
[ai-workflow] Phase 9 (report) - completed

Issue: #123
Phase: 9 (report)
Status: completed
Review: N/A

Auto-generated by AI Workflow
```

**問題点**: Phase番号が間違っている（8のはずが9）。また、ログクリーンアップの内容が明示されていない。

### 提案する改善内容

`src/core/git-manager.ts` に新しいメソッドを追加：

```typescript
/**
 * ログクリーンアップ用のコミットを作成
 */
public async commitCleanupLogs(
  issueNumber: number,
  phase: 'report' | 'evaluation'
): Promise<CommitResult> {
  const changedFiles = await this.getChangedFiles();
  const targetFiles = this.filterPhaseFiles(changedFiles, issueNumber.toString());

  if (targetFiles.length === 0) {
    console.warn('[WARNING] No files to commit for cleanup');
    return {
      success: true,
      commit_hash: null,
      files_committed: [],
    };
  }

  await this.git.add(targetFiles);
  await this.ensureGitConfig();

  const message = this.createCleanupCommitMessage(issueNumber, phase);

  try {
    const commitResponse = await this.git.commit(message, targetFiles, {
      '--no-verify': null,
    });

    console.info(`[INFO] Cleanup commit created: ${commitResponse.commit ?? 'unknown'}`);

    return {
      success: true,
      commit_hash: commitResponse.commit ?? null,
      files_committed: targetFiles,
    };
  } catch (error) {
    console.error(`[ERROR] Cleanup commit failed: ${(error as Error).message}`);
    return {
      success: false,
      commit_hash: null,
      files_committed: targetFiles,
      error: `Cleanup commit failed: ${(error as Error).message}`,
    };
  }
}

/**
 * ログクリーンアップ用のコミットメッセージを生成
 */
private createCleanupCommitMessage(
  issueNumber: number,
  phase: 'report' | 'evaluation'
): string {
  const phaseNumber = phase === 'report' ? 8 : 9;

  return [
    `[ai-workflow] Clean up workflow execution logs`,
    '',
    `Issue: #${issueNumber}`,
    `Phase: ${phaseNumber} (${phase})`,
    `Action: Remove agent execution logs (execute/review/revise directories)`,
    `Preserved: metadata.json, output/*.md`,
    '',
    'Auto-generated by AI Workflow',
  ].join('\n');
}
```

`src/phases/report.ts:30-34` を修正：

```typescript
// 変更前:
if (gitManager) {
  await this.autoCommitAndPush(gitManager, null);
  console.info('[INFO] Cleanup changes committed and pushed.');
}

// 変更後:
if (gitManager) {
  const commitResult = await gitManager.commitCleanupLogs(issueNumber, 'report');

  if (!commitResult.success) {
    throw new Error(`Git commit failed: ${commitResult.error ?? 'unknown error'}`);
  }

  const pushResult = await gitManager.pushToRemote();
  if (!pushResult.success) {
    throw new Error(`Git push failed: ${pushResult.error ?? 'unknown error'}`);
  }

  console.info('[INFO] Cleanup changes committed and pushed.');
}
```

## 問題3: Planning Phase（Phase 0）のログが削除されない

### 現在の動作

`src/phases/report.ts:323-333` で、`00_planning` が意図的に削除対象外になっています：

```typescript
// Planning フェーズ（00_planning）は削除対象外（Issue参照ソースとして保持）
const phaseDirectories = [
  '01_requirements',
  '02_design',
  '03_test_scenario',
  '04_implementation',
  '05_test_implementation',
  '06_testing',
  '07_documentation',
  '08_report',
];
```

**問題点**: `output/planning.md` は保持されるべきだが、`execute/`, `review/`, `revise/` ディレクトリは不要。

### 提案する改善内容

`src/phases/report.ts:324-333` を修正：

```typescript
// すべてのフェーズ（00-08）の実行ログを削除
const phaseDirectories = [
  '00_planning',  // ← 追加
  '01_requirements',
  '02_design',
  '03_test_scenario',
  '04_implementation',
  '05_test_implementation',
  '06_testing',
  '07_documentation',
  '08_report',
];
```

## 問題4: Evaluation Phase完了後のログクリーンアップが未実装

### 現在の動作

- Evaluation Phase完了後、`--cleanup-on-complete` オプションでワークフロー全体を削除できる
- しかし、ログだけを削除するオプションがない

### 提案する改善内容

`src/phases/evaluation.ts` に Report Phase と同様のログクリーンアップを実装：

```typescript
public async run(options: PhaseRunOptions = {}): Promise<boolean> {
  // 親クラスの run() を実行（execute + review cycle）
  const success = await super.run(options);

  // すべての処理が成功した場合のみ、ログをクリーンアップ
  if (success && !options.cleanupOnComplete) {
    const gitManager = options.gitManager ?? null;
    const issueNumber = parseInt(this.metadata.data.issue_number, 10);
    try {
      await this.cleanupWorkflowLogs(issueNumber);
      console.info('[INFO] Workflow logs cleaned up successfully.');

      // ログクリーンナップによる削除をコミット・プッシュ
      if (gitManager) {
        const commitResult = await gitManager.commitCleanupLogs(issueNumber, 'evaluation');

        if (!commitResult.success) {
          throw new Error(`Git commit failed: ${commitResult.error ?? 'unknown error'}`);
        }

        const pushResult = await gitManager.pushToRemote();
        if (!pushResult.success) {
          throw new Error(`Git push failed: ${pushResult.error ?? 'unknown error'}`);
        }

        console.info('[INFO] Cleanup changes committed and pushed.');
      }
    } catch (error) {
      const message = (error as Error).message ?? String(error);
      console.warn(`[WARNING] Failed to cleanup workflow logs: ${message}`);
    }
  }

  // オプションが指定されている場合は、ワークフロー全体を削除
  if (success && options.cleanupOnComplete) {
    const force = options.cleanupOnCompleteForce ?? false;
    await this.cleanupWorkflowArtifacts(force);
  }

  return success;
}

/**
 * ワークフローログをクリーンアップ
 */
private async cleanupWorkflowLogs(issueNumber: number): Promise<void> {
  const baseDir = path.resolve(this.metadata.workflowDir, '..', `issue-${issueNumber}`);

  // すべてのフェーズ（00-09）の実行ログを削除
  const phaseDirectories = [
    '00_planning',
    '01_requirements',
    '02_design',
    '03_test_scenario',
    '04_implementation',
    '05_test_implementation',
    '06_testing',
    '07_documentation',
    '08_report',
    '09_evaluation',
  ];

  const targetSubdirs = ['execute', 'review', 'revise'];

  let deletedCount = 0;
  let skippedCount = 0;

  for (const phaseDir of phaseDirectories) {
    const phasePath = path.join(baseDir, phaseDir);

    if (!fs.existsSync(phasePath)) {
      skippedCount++;
      continue;
    }

    for (const subdir of targetSubdirs) {
      const subdirPath = path.join(phasePath, subdir);

      if (fs.existsSync(subdirPath)) {
        try {
          fs.removeSync(subdirPath);
          deletedCount++;
          console.info(`[INFO] Deleted: ${path.relative(baseDir, subdirPath)}`);
        } catch (error) {
          const message = (error as Error).message ?? String(error);
          console.warn(`[WARNING] Failed to delete ${subdirPath}: ${message}`);
        }
      }
    }
  }

  console.info(
    `[INFO] Cleanup summary: ${deletedCount} directories deleted, ${skippedCount} phase directories skipped.`,
  );
}
```

## 期待される効果

1. **明確なコミット履歴**: 各操作の目的が一目でわかる
2. **リポジトリサイズの削減**: Planning Phaseの実行ログも削除されるため、さらに約5-10%のサイズ削減
3. **柔軟なクリーンアップ**: Evaluation Phase完了後に、ログだけ削除するか、全体を削除するか選択可能

## 実装の優先順位

1. **最優先**: メタデータ初期化時のコミットメッセージ修正
2. **高**: ログクリーンアップ時のコミットメッセージ修正
3. **高**: Planning（Phase 0）のログ削除
4. **中**: Evaluation Phaseでのログクリーンアップ

## 参考

- メタデータ初回コミット: `src/main.ts:389-393`
- Report Phase クリーンアップ: `src/phases/report.ts:312-367`
- コミットメッセージ生成: `src/core/git-manager.ts:245-277`
- Evaluation Phase 全体削除: `src/phases/base-phase.ts:977-1026`


## 品質ゲート（Phase 2）

設計書は以下の品質ゲートをクリアする必要があります：

- [ ] **実装戦略の判断根拠が明記されている**
- [ ] **テスト戦略の判断根拠が明記されている**
- [ ] **既存コードへの影響範囲が分析されている**
- [ ] **変更が必要なファイルがリストアップされている**
- [ ] **設計が実装可能である**

## ⚠️ 重要: Planning Phaseチェックリストとの照合（必須）

### 1. Planning.mdの読み込み

以下のファイルを読み込んでください：
- @.ai-workflow/issue-16/00_planning/output/planning.md

### 2. 該当フェーズのチェックリストを抽出

Planning.mdから、現在のフェーズ（"### Phase 2:" または "## Phase 2:"）のセクションを見つけ、タスクチェックリストを抽出してください。

**注意**: チェックリストが見つからない場合は、このチェックをスキップしてください。

### 3. 設計内容との照合

設計書（design.md）と照合し、各タスクが完了しているかチェックしてください。

**完了の判定基準**:
- Task記載の設計項目が記述されているか
- Task記載の戦略判断が明記されているか
- サブタスクがすべて完了しているか

### 4. Planning.mdの更新

照合結果に基づき、planning.mdのチェックボックスを更新してください：

- 完了したタスク: `- [ ]` → `- [x]`
- 未完了のタスク: `- [ ]` のまま

**Editツールを使用**して、該当フェーズのセクションを更新してください。

### 5. レビュー判定への反映

- **すべてのタスクが完了**（全て `[x]`）: PASS または PASS_WITH_SUGGESTIONS
- **未完了タスクがある**（`[ ]` が残っている）: FAIL
  - レビューフィードバックに未完了タスクをリストアップ
  - 具体的に何が不足しているか説明

**例（FAIL時のフィードバック）**:
```
## Planning Phaseチェックリスト照合結果: FAIL

以下のタスクが未完了です：

- [ ] Task 2-2: テスト戦略の決定
  - 不足: テスト戦略の判断根拠が記載されていません
- [ ] Task 2-3: 影響範囲分析
  - 不足: 既存コードへの影響範囲が分析されていません

これらのタスクを完了してから再提出してください。
```

### ⚠️ 重要: Planning.mdの内容はレビュー結果に含めない

Planning.mdの読み込みと照合作業は必要ですが、**planning.mdの全文やPlanning Phaseのレビュー内容をレビュー結果に含めないでください**。

レビュー結果には以下のみを含めること:
- 設計書（design.md）に対する評価
- Planning.mdとの照合で発見した未完了タスク（FAIL時のみ）
- 設計書固有の改善提案

Planning Phaseのレビュー詳細やplanning.mdの内容全体は出力しないこと。

## レビュー姿勢

このレビューは「**80点で十分**」の原則に基づいて実施してください：

1. **完璧ではなく、十分を目指す**
   - 設計書が次フェーズ（テストシナリオ作成）に進める状態であれば合格
   - 細かい表現の改善は改善提案として記載（ブロッカーにしない）

2. **ブロッカーと改善提案を明確に区別**
   - ブロッカー: 次フェーズ（テストシナリオ）に進めない重大な問題
   - 改善提案: 次フェーズに進めるが、改善が望ましい事項

3. **実用的でバランスの取れた判断**
   - プロジェクトを前に進めることを最優先
   - 実装フェーズで対応可能な問題はブロッカーにしない

4. **建設的なフィードバック**
   - 「ダメ」ではなく「こうすればより良い」という表現
   - 具体的な改善案を提示

## レビュー観点

### 1. 戦略判断の妥当性（最重要）

**実装戦略（CREATE/EXTEND/REFACTOR）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 要件定義書の内容と整合しているか
- 既存コードへの影響が適切に評価されているか

**テスト戦略（UNIT_ONLY/INTEGRATION_ONLY/BDD_ONLY/UNIT_INTEGRATION/UNIT_BDD/INTEGRATION_BDD/ALL）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 機能の複雑度に見合ったテスト戦略か
- 要件定義の受け入れ基準と整合しているか

**テストコード戦略（EXTEND_TEST/CREATE_TEST/BOTH_TEST）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 既存テストとの関係が明確か

### 2. 影響範囲分析の適切性

- 既存コードへの影響が網羅的に分析されているか
- 依存関係が正しく把握されているか
- マイグレーションの必要性が評価されているか

### 3. ファイルリストの完全性

- 新規作成ファイルがリストアップされているか
- 修正が必要な既存ファイルがリストアップされているか
- パスが具体的で実装可能か

### 4. 設計の実装可能性

- 設計が具体的で実装者が迷わないか
- 技術的に実装可能な設計か
- 既存プロジェクトの規約・パターンに準拠しているか

### 5. 要件との対応（トレーサビリティ）

- 要件定義書の各要件に対応する設計があるか
- 要件の漏れがないか

### 6. セキュリティ考慮

- セキュリティリスクが識別されているか
- 対策が具体的か

### 7. 非機能要件への対応

- パフォーマンス考慮があるか
- スケーラビリティ考慮があるか
- 保守性考慮があるか

## ブロッカー（BLOCKER）と改善提案（SUGGESTION）の区別

### ブロッカー（BLOCKER）: 次フェーズに進めない重大な問題

**ブロッカーの例**:
- 3つの戦略判断（実装・テスト・テストコード）のいずれかが欠落
- 判断根拠が記載されていない、または論理的に破綻している
- 変更ファイルリストが未記載
- 設計が実装不可能（技術的制約に違反）
- 既存システムを破壊する設計
- 重大なセキュリティリスクが未対策
- 要件との対応が不明確

### 改善提案（SUGGESTION）: 次フェーズに進めるが、改善が望ましい事項

**改善提案の例**:
- より良い設計パターンの提案
- パフォーマンス最適化の余地
- ドキュメントの充実（例: 図表追加）
- エッジケースの追加考慮
- より詳細な影響範囲分析
- セキュリティ対策の強化

## 出力フォーマット

以下の形式で出力してください：

```markdown
## 品質ゲート評価

- [x/  ] **実装戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **テスト戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **既存コードへの影響範囲が分析されている**: PASS/FAIL - （コメント）
- [x/  ] **変更が必要なファイルがリストアップされている**: PASS/FAIL - （コメント）
- [x/  ] **設計が実装可能である**: PASS/FAIL - （コメント）

## 詳細レビュー

### 1. 戦略判断の妥当性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 2. 影響範囲分析の適切性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 3. ファイルリストの完全性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 4. 設計の実装可能性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 5. 要件との対応

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 6. セキュリティ考慮

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

### 7. 非機能要件への対応

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

## ブロッカー（BLOCKER）

**次フェーズに進めない重大な問題**

（ブロッカーがある場合のみ記載）
1. **（ブロッカー1のタイトル）**
   - 問題: （具体的な問題）
   - 影響: （次フェーズにどう影響するか）
   - 対策: （どう修正すべきか）

## 改善提案（SUGGESTION）

**次フェーズに進めるが、改善が望ましい事項**

（改善提案がある場合のみ記載）
1. **（提案1のタイトル）**
   - 現状: （現在の状態）
   - 提案: （こうすればより良い）
   - 効果: （改善による効果）

## 総合評価

（設計書全体の総合的な評価）

**主な強み**:
- （良い点をまとめる）

**主な改善提案**:
- （改善提案をまとめる）

（総括コメント）

---
**判定: PASS / PASS_WITH_SUGGESTIONS / FAIL**
```

## レビュー実施

上記フォーマットに従って、設計書のクリティカルシンキングレビューを実施してください。

## ⚠️ 重要: 判定の出力は必須

**レビュー結果の最後に、必ず以下のいずれかの形式で判定を出力してください：**

```
---
**判定: PASS**
```

または

```
---
**判定: PASS_WITH_SUGGESTIONS**
```

または

```
---
**判定: FAIL**
```

**この判定がないと、レビュー結果が正しく処理されません。必ず3つのいずれかの判定を、上記の正確な形式で明示的に出力してください。**
