# 要件定義書 - Issue #155

## プロジェクト情報

- **Issue番号**: #155
- **タイトル**: [Refactor] コード重複の削減: repository-analyzer.ts
- **カテゴリ**: リファクタリング
- **優先度**: High
- **作成日**: 2025-01-30

---

## 0. Planning Documentの確認

Planning Phaseで策定された開発計画を確認し、本要件定義書の基礎としました：

### 開発戦略の概要

- **実装戦略**: REFACTOR（既存機能を変更せず、構造改善のみ実施）
- **テスト戦略**: UNIT_INTEGRATION（新規メソッドのユニットテスト + 既存メソッドのリグレッションテスト）
- **テストコード戦略**: EXTEND_TEST（既存テストファイルに追加）
- **見積もり工数**: 10~14時間（Phase 0-8の合計）
- **複雑度**: 中程度
- **リスク評価**: 中（エッジケースの見逃し、テストモックの複雑化）

### 主要な制約条件

- publicインターフェース（メソッドシグネチャ、戻り値）は完全に維持
- 外部への影響は最小限（単一ファイルの変更）
- 新規依存関係の追加なし
- マイグレーション不要

---

## 1. 概要

### 1.1 背景

`src/core/repository-analyzer.ts`内の`analyze()`メソッド（234-305行）と`analyzeForRefactoring()`メソッド（315-386行）に約150行の重複したエージェントフォールバックロジックが存在します。この重複により以下の問題が発生しています：

- **保守性の低下**: エージェントフォールバック動作の変更が必要な場合、2箇所以上の修正が必要となり、修正漏れのリスクが高い
- **コードの可読性低下**: 約150行の重複コードがメンテナンスコストを増加させ、新規参加者の理解を妨げている
- **バグ混入リスク**: 同一ロジックが複数箇所に存在するため、一方のみ修正してバグが発生する可能性が高い

### 1.2 目的

**ビジネス価値**:
- 保守コストの削減（エージェント実行ロジックの変更を1箇所で管理可能）
- 開発速度の向上（重複コードの削減により、変更時の影響範囲が明確化）
- 品質向上（共通ロジックのテストに集中でき、テストカバレッジが向上）

**技術的価値**:
- DRY原則（Don't Repeat Yourself）の徹底
- Martin Fowlerの「Extract Method」パターンの適用
- 単一責任の原則（SRP）に基づくメソッド分割
- 約150行のコード削減（67%のコード削減率）

### 1.3 スコープ

**対象範囲**:
- `src/core/repository-analyzer.ts`ファイルのリファクタリング
- `analyze()`メソッド（234-305行）のリファクタリング
- `analyzeForRefactoring()`メソッド（315-386行）のリファクタリング
- 新規プライベートメソッドの追加（`executeAgentWithFallback`、`validateAnalysisResult`）

**対象外**:
- 他のファイルへの影響（publicインターフェースは維持）
- 新規機能の追加
- エージェントフォールバックロジックの動作変更
- パフォーマンスチューニング（コード削減による副次的効果は期待）

---

## 2. 機能要件

### FR-1: 共通エージェント実行メソッドの抽出（優先度: 高）

**要件**: `analyze()`と`analyzeForRefactoring()`の重複するエージェント実行ロジックを、単一の共通メソッドに抽出する。

**詳細**:
- メソッド名: `executeAgentWithFallback`
- メソッドシグネチャ:
  ```typescript
  private async executeAgentWithFallback(
    promptPath: string,
    outputFilePath: string,
    repoPath: string
  ): Promise<void>
  ```
- 処理フロー:
  1. プロンプトテンプレートファイルの読み込み（`fs.readFileSync`）
  2. 変数置換（`{repository_path}`, `{output_file_path}`）
  3. エージェント選択ロジック（Codex → Claude フォールバック）
  4. エージェント実行（`this.codexClient.executeTask` または `this.claudeClient.executeTask`）
  5. エラーハンドリング（認証エラー、実行失敗）

**受け入れ基準**:
- **Given**: Codexエージェントが利用可能な状態で、`executeAgentWithFallback`を呼び出す
- **When**: プロンプトテンプレートと出力ファイルパスを指定して実行する
- **Then**: Codexエージェントが正常に実行され、出力ファイルが生成される

- **Given**: Codexエージェントが利用不可能な状態（`this.codexClient === null`）で、`executeAgentWithFallback`を呼び出す
- **When**: `agent`パラメータが`'auto'`の場合
- **Then**: Claudeエージェントに自動的にフォールバックし、正常に実行される

- **Given**: Codexエージェント実行中にエラーが発生した状態で、`executeAgentWithFallback`を呼び出す
- **When**: `agent`パラメータが`'auto'`の場合
- **Then**: エラーをログに記録し、Claudeエージェントにフォールバックし、正常に実行される

- **Given**: プロンプトテンプレートファイルが存在しない状態で、`executeAgentWithFallback`を呼び出す
- **When**: 存在しないプロンプトパスを指定する
- **Then**: `Error`例外をスローし、エラーメッセージ「Prompt template not found: {path}」を含む

### FR-2: 共通バリデーションメソッドの抽出（優先度: 高）

**要件**: `analyze()`と`analyzeForRefactoring()`で使用されるバリデーションロジックを、候補タイプ別に統合した共通メソッドに抽出する。

**詳細**:
- メソッド名: `validateAnalysisResult`
- メソッドシグネチャ:
  ```typescript
  private validateAnalysisResult(
    candidates: BugCandidate[] | RefactorCandidate[],
    candidateType: 'bug' | 'refactor'
  ): BugCandidate[] | RefactorCandidate[]
  ```
- 処理フロー:
  1. `candidateType`パラメータに基づいて適切なバリデーションメソッドを選択
  2. `candidateType === 'bug'`の場合: `this.validateBugCandidate`を使用
  3. `candidateType === 'refactor'`の場合: `this.validateRefactorCandidate`を使用
  4. 有効な候補のみをフィルタリングして返却

**受け入れ基準**:
- **Given**: バグ候補のリストが与えられた状態で、`validateAnalysisResult`を呼び出す
- **When**: `candidateType`を`'bug'`に指定する
- **Then**: `validateBugCandidate`メソッドが各候補に対して呼び出され、有効な候補のみが返される

- **Given**: リファクタリング候補のリストが与えられた状態で、`validateAnalysisResult`を呼び出す
- **When**: `candidateType`を`'refactor'`に指定する
- **Then**: `validateRefactorCandidate`メソッドが各候補に対して呼び出され、有効な候補のみが返される

- **Given**: 15個の候補のうち3個が無効な状態で、`validateAnalysisResult`を呼び出す
- **When**: バリデーションを実行する
- **Then**: ログに「Parsed 15 candidates, 12 valid after validation.」と記録され、12個の有効な候補が返される

### FR-3: `analyze()`メソッドのリファクタリング（優先度: 高）

**要件**: 既存の`analyze()`メソッドを、新規作成した共通メソッドを使用する形にリファクタリングする。

**詳細**:
- 既存のpublicインターフェースを完全に維持（メソッドシグネチャ、戻り値、例外）
- 重複コード（234-305行）を共通メソッド呼び出しに置き換え
- 以下の処理フローに統合:
  1. `executeAgentWithFallback`でエージェント実行
  2. `readOutputFile`で出力ファイル読み込み
  3. `validateAnalysisResult`でバリデーション
  4. `cleanupOutputFile`でクリーンアップ

**受け入れ基準**:
- **Given**: リファクタリング前の`analyze()`メソッドの動作が記録されている状態
- **When**: リファクタリング後の`analyze()`メソッドを同じ入力で実行する
- **Then**: 戻り値、ログ出力、副作用（ファイル生成・削除）がリファクタリング前と完全に一致する

- **Given**: `analyze()`メソッドを呼び出すすべての既存コード
- **When**: リファクタリング後の`analyze()`メソッドを使用する
- **Then**: コンパイルエラーが発生せず、実行時の動作が変わらない

### FR-4: `analyzeForRefactoring()`メソッドのリファクタリング（優先度: 高）

**要件**: 既存の`analyzeForRefactoring()`メソッドを、新規作成した共通メソッドを使用する形にリファクタリングする。

**詳細**:
- 既存のpublicインターフェースを完全に維持（メソッドシグネチャ、戻り値、例外）
- 重複コード（315-386行）を共通メソッド呼び出しに置き換え
- 以下の処理フローに統合:
  1. `executeAgentWithFallback`でエージェント実行
  2. `readRefactorOutputFile`で出力ファイル読み込み
  3. `validateAnalysisResult`でバリデーション
  4. `cleanupOutputFile`でクリーンアップ

**受け入れ基準**:
- **Given**: リファクタリング前の`analyzeForRefactoring()`メソッドの動作が記録されている状態
- **When**: リファクタリング後の`analyzeForRefactoring()`メソッドを同じ入力で実行する
- **Then**: 戻り値、ログ出力、副作用（ファイル生成・削除）がリファクタリング前と完全に一致する

- **Given**: `analyzeForRefactoring()`メソッドを呼び出すすべての既存コード
- **When**: リファクタリング後の`analyzeForRefactoring()`メソッドを使用する
- **Then**: コンパイルエラーが発生せず、実行時の動作が変わらない

### FR-5: 既存テストの維持（優先度: 中）

**要件**: 既存のテストケースがすべてパスすることを保証する。

**詳細**:
- `tests/unit/core/repository-analyzer.test.ts`に存在する既存テストをすべて維持
- リファクタリング後も既存テストが100%パスすること
- 新規テストケースは既存テストファイルに追加（EXTEND_TEST戦略）

**受け入れ基準**:
- **Given**: リファクタリング前のテストスイートが100%パスしている状態
- **When**: リファクタリング後のテストスイートを実行する
- **Then**: すべてのテストケースがパスし、テストカバレッジが90%以上である

---

## 3. 非機能要件

### NFR-1: パフォーマンス要件

**要件**: リファクタリング前後でパフォーマンスが有意に劣化しないこと。

**詳細**:
- メソッド抽出による関数呼び出しオーバーヘッドは、Node.jsのV8エンジンのインライン化により最小化される
- 実行時間の変動は±5%以内であること（測定誤差の範囲内）

**受け入れ基準**:
- **Given**: リファクタリング前の`analyze()`メソッドの平均実行時間が記録されている状態
- **When**: リファクタリング後の`analyze()`メソッドを100回実行して平均実行時間を測定する
- **Then**: 平均実行時間の変動が±5%以内である

### NFR-2: 保守性要件

**要件**: コードの保守性を大幅に向上させること。

**詳細**:
- コード削減率: 約67%（約150行 → 約50行）
- 重複コードの完全な削除
- エージェント実行ロジックの変更箇所を1箇所に集約

**受け入れ基準**:
- **Given**: リファクタリング後のコードベース
- **When**: エージェントフォールバックロジックの変更が必要になる
- **Then**: 変更箇所が1箇所（`executeAgentWithFallback`メソッド）のみで済む

### NFR-3: テスタビリティ要件

**要件**: テストカバレッジを90%以上に維持すること。

**詳細**:
- 新規メソッド（`executeAgentWithFallback`、`validateAnalysisResult`）のユニットテストを追加
- 既存メソッド（`analyze`、`analyzeForRefactoring`）のリグレッションテストを維持
- モッククリーンアップ（`afterEach(() => jest.restoreAllMocks())`）を実装

**受け入れ基準**:
- **Given**: リファクタリング後のテストスイート
- **When**: カバレッジレポートを生成する
- **Then**: テストカバレッジが90%以上である

### NFR-4: 可読性要件

**要件**: コードの可読性を向上させること。

**詳細**:
- メソッド名が処理内容を明確に表現している（`executeAgentWithFallback`、`validateAnalysisResult`）
- 各メソッドが単一責任の原則（SRP）に従っている
- JSDocコメントで各メソッドの責務を明確に記述

**受け入れ基準**:
- **Given**: リファクタリング後のコード
- **When**: コードレビューを実施する
- **Then**: レビュアーが「コードの意図が明確である」と評価する

---

## 4. 制約事項

### 4.1 技術的制約

- **既存インターフェースの維持**: `analyze()`と`analyzeForRefactoring()`のpublicインターフェース（メソッドシグネチャ、戻り値、例外）を完全に維持すること
- **新規依存関係の禁止**: 新しいnpmパッケージや外部ライブラリの追加は行わないこと
- **TypeScript 5.x対応**: TypeScript 5.xの厳格な型チェックに準拠すること
- **コーディング規約**: プロジェクトのESLintルール（`no-console`、`no-process-env`等）に準拠すること

### 4.2 リソース制約

- **工数制限**: 見積もり工数10~14時間以内に完了すること
- **リリーススケジュール**: Phase 0-8を順次実行し、Phase 8（Report）で完了すること
- **テスト時間**: テスト実行時間は30分以内であること

### 4.3 ポリシー制約

- **破壊的変更の禁止**: 既存の呼び出し側に影響を与える破壊的変更は行わないこと
- **セキュリティポリシー**: パストラバーサル攻撃防止、ReDoS攻撃防止を維持すること
- **ロギングポリシー**: 統一loggerモジュール（`src/utils/logger.ts`）を使用し、`console.log`の直接使用は禁止

---

## 5. 前提条件

### 5.1 システム環境

- Node.js 20以上
- npm 10以上
- TypeScript 5.x
- Jest（テストフレームワーク）

### 5.2 依存コンポーネント

- `CodexAgentClient`: Codexエージェント実行クライアント
- `ClaudeAgentClient`: Claudeエージェント実行クライアント
- `fs-extra`: ファイルI/Oライブラリ
- `logger`: 統一ログモジュール（`src/utils/logger.ts`）
- `getErrorMessage`: エラーハンドリングユーティリティ（`src/utils/error-utils.ts`）

### 5.3 外部システム連携

- Codex API（`CODEX_API_KEY`環境変数が設定されている場合）
- Claude Code SDK（`CLAUDE_CODE_CREDENTIALS_PATH`環境変数が設定されている場合）

---

## 6. 受け入れ基準

### AC-1: 機能要件の充足

- [ ] **FR-1**: `executeAgentWithFallback`メソッドが実装され、すべての受け入れ基準を満たす
- [ ] **FR-2**: `validateAnalysisResult`メソッドが実装され、すべての受け入れ基準を満たす
- [ ] **FR-3**: `analyze()`メソッドがリファクタリングされ、既存の動作が維持される
- [ ] **FR-4**: `analyzeForRefactoring()`メソッドがリファクタリングされ、既存の動作が維持される
- [ ] **FR-5**: 既存テストがすべてパスし、新規テストが追加される

### AC-2: 非機能要件の充足

- [ ] **NFR-1**: リファクタリング前後でパフォーマンスの有意な劣化がない（±5%以内）
- [ ] **NFR-2**: コード削減率が約67%を達成（約150行 → 約50行）
- [ ] **NFR-3**: テストカバレッジが90%以上である
- [ ] **NFR-4**: コードレビューで可読性の向上が確認される

### AC-3: 品質ゲート（Phase 1）の充足

- [ ] **機能要件が明確に記載されている**: FR-1〜FR-5がすべて明確に定義されている
- [ ] **受け入れ基準が定義されている**: 各機能要件に対してGiven-When-Then形式の受け入れ基準が記載されている
- [ ] **スコープが明確である**: 対象範囲と対象外が明確に区分されている
- [ ] **論理的な矛盾がない**: 機能要件、非機能要件、制約事項の間に矛盾が存在しない

### AC-4: リグレッションテストの成功

- [ ] 既存の`analyze()`メソッドを呼び出すすべてのテストケースがパスする
- [ ] 既存の`analyzeForRefactoring()`メソッドを呼び出すすべてのテストケースがパスする
- [ ] リファクタリング前後の出力が完全に一致する（統合テストで検証）

### AC-5: ドキュメントの更新

- [ ] JSDocコメントが新規メソッドに追加されている
- [ ] リファクタリング後の`analyze()`、`analyzeForRefactoring()`のコメントが更新されている
- [ ] ARCHITECTURE.mdにリファクタリング内容が反映されている（オプション）

---

## 7. スコープ外

### 7.1 明確にスコープ外とする事項

- **他のファイルのリファクタリング**: `repository-analyzer.ts`以外のファイルは対象外
- **新規機能の追加**: エージェントフォールバックロジックの動作変更や新規エージェントの追加は対象外
- **パフォーマンスチューニング**: コード削減による副次的効果は期待するが、専用のパフォーマンス最適化は対象外
- **エージェントクライアントの変更**: `CodexAgentClient`や`ClaudeAgentClient`の内部実装は対象外
- **プロンプトテンプレートの変更**: `src/prompts/auto-issue/detect-bugs.txt`や`detect-refactoring.txt`の内容変更は対象外

### 7.2 将来的な拡張候補

- **Template Method パターンの適用**: `executeAgentWithFallback`をさらに抽象化し、テンプレートメソッドパターンを適用することで、新規候補タイプ（`enhancement`等）への拡張を容易にする
- **エージェント選択戦略のカスタマイズ**: エージェント選択ロジックをStrategy パターンで抽出し、動的な選択ルールのカスタマイズを可能にする
- **出力ファイル管理の強化**: 一時ファイルの自動クリーンアップやリトライロジックの追加

---

## 8. リスクと対策

### リスク1: エッジケースの見逃し（影響度: 中、確率: 中）

**詳細**: エージェントフォールバックロジックには複数の分岐（Codex成功/失敗、Claude成功/失敗）があり、エッジケースの見逃しによりバグが混入する可能性がある。

**対策**:
- Phase 3で網羅的なテストシナリオを作成（正常系、異常系、境界値）
- Phase 5でカバレッジ90%以上を目標にテスト実装
- リファクタリング前後の出力を比較するインテグレーションテストを必須化

### リスク2: テストモックの複雑化（影響度: 低~中、確率: 中）

**詳細**: `executeAgentWithFallback`メソッドは複数の外部依存（CodexAgentClient、ClaudeAgentClient、fs-extra）を持つため、テストモックが複雑になる。

**対策**:
- Phase 5でモック設定のヘルパー関数を作成（`setupMocks()`）
- `jest.spyOn()`を活用し、モック範囲を最小化
- Issue #115のベストプラクティス（型パラメータ明示、`afterEach()`でのモッククリーンアップ）を適用

### リスク3: 既存テストの不足（影響度: 中、確率: 中）

**詳細**: 既存のテストカバレッジが不足している場合、リファクタリングによるリグレッションを検出できない。

**対策**:
- Phase 1で既存テストカバレッジを確認（`npm run test:coverage`）
- カバレッジが80%未満の場合、Phase 5で追加テストを実装
- リグレッション検証用のインテグレーションテストを必須化

---

## 9. 成功基準

本リファクタリングが成功したと判断する基準を以下に示します：

### 定量的成功基準

- [ ] **コード削減率**: 約67%達成（約150行 → 約50行）
- [ ] **テストカバレッジ**: 90%以上維持
- [ ] **テスト成功率**: 既存テスト100%パス、新規テスト100%パス
- [ ] **パフォーマンス変動**: ±5%以内

### 定性的成功基準

- [ ] **保守性向上**: コードレビューで「エージェント実行ロジックの変更が1箇所で済む」と評価される
- [ ] **可読性向上**: コードレビューで「コードの意図が明確である」と評価される
- [ ] **テスト容易性向上**: コードレビューで「共通ロジックのテストに集中できる」と評価される

### ビジネス価値の実現

- [ ] **開発速度向上**: エージェント関連の変更時に、修正箇所が1箇所に集約される
- [ ] **品質向上**: 重複コード削減により、バグ混入リスクが低減される
- [ ] **新規参加者の理解促進**: コードの可読性向上により、オンボーディング時間が短縮される

---

## 10. 補足情報

### 10.1 参考資料

- **Planning Document**: `.ai-workflow/issue-155/00_planning/output/planning.md`
- **CLAUDE.md**: プロジェクト全体方針とコーディングガイドライン
- **ARCHITECTURE.md**: アーキテクチャ設計思想（ファサードパターン、モジュール分離）
- **Issue #115**: テストコード品質のベストプラクティス（モッククリーンアップ、型パラメータ明示）
- **Issue #26**: Agent関連モジュールのリファクタリング事例
- Martin Fowler『リファクタリング（第2版）』「Extract Method」「Template Method」パターン

### 10.2 関連Issue

- Issue #126: バグ検出機能の実装（`analyze()`メソッドの使用例）
- Issue #127: リファクタリング検出機能の実装（`analyzeForRefactoring()`メソッドの使用例）
- Issue #144: RepositoryAnalyzerの汎用化（30+ 言語サポート）

### 10.3 用語定義

- **エージェントフォールバック**: Codexエージェント実行失敗時に、自動的にClaudeエージェントに切り替える仕組み
- **候補タイプ**: 検出対象の種類（`'bug'` | `'refactor'`）
- **DRY原則**: Don't Repeat Yourself（同じコードを繰り返し書かない）
- **SRP**: Single Responsibility Principle（単一責任の原則）
- **Extract Method パターン**: 重複するコードを共通メソッドに抽出するリファクタリング手法

---

## 承認

本要件定義書は、Phase 1（Requirements）の成果物として、以下の品質ゲートを満たしていることを確認しました：

- ✅ **機能要件が明確に記載されている**: FR-1〜FR-5が詳細に定義されている
- ✅ **受け入れ基準が定義されている**: Given-When-Then形式で検証可能な基準が記載されている
- ✅ **スコープが明確である**: 対象範囲と対象外が明確に区分されている
- ✅ **論理的な矛盾がない**: Planning Documentの戦略と整合性が取れている

次のPhase 2（Design）では、本要件定義書に基づいて詳細設計を実施します。

---

**作成日**: 2025-01-30
**バージョン**: 1.0
**作成者**: AI Workflow Agent (Requirements Phase)
