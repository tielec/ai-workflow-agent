# 要件定義書 - Issue #243

## 0. Planning Documentの確認

Planning Phase（Issue #243）で策定された開発計画を確認しました。

### 開発戦略の確認
- **実装戦略**: EXTEND（既存コードの拡張、`content-parser.ts`、`review-cycle-manager.ts`、`phase-runner.ts`の修正）
- **テスト戦略**: UNIT_INTEGRATION（ユニットテスト + インテグレーションテスト）
- **テストコード戦略**: EXTEND_TEST（既存テストファイルの拡張）
- **見積もり工数**: 8~12時間
- **リスクレベル**: 中（LLMレスポンス形式の多様性、既存の正常なレビュー結果が誤ってFAIL判定されるリスク）

### 実装優先順位
1. **最優先**: JSON抽出前処理（Task 4-1） - バグの根本原因
2. **高優先**: フォールバック判定ロジック改善（Task 4-2） - 誤検出防止
3. **中優先**: リトライ上限処理（Task 4-3） - 後続フェーズへの進行防止

### 品質ゲート
Planning Phaseで定義された品質ゲート（8フェーズ）を踏まえ、Phase 1では以下を重視：
- バグの根本原因が明確に特定されている
- 受け入れ基準が検証可能な形式で定義されている
- エッジケースが洗い出されている

---

## 1. 概要

### 背景
AI Workflow Agentのレビューサイクル機能において、LLM（Claude Agent / Codex Agent）によるレビュー結果が「FAIL」判定であるにもかかわらず、revise（修正）ステップが実行されず、後続フェーズに進んでしまう致命的なバグが発生している。

### 問題の本質
1. **JSONパースエラー**: LLMがJSON後に余計なテキストを付けて返すため、`JSON.parse()` が失敗
2. **フォールバック判定の誤検出**: パース失敗後のフォールバックロジックで「PASS判定が可能になります」等の文字列により、FAIL判定がPASSに誤変換される
3. **リトライ制御の不備**: FAIL判定でもreviseが実行されず、リトライ上限（3回）超過時の処理が不完全

### 目的
- **主目的**: レビュー結果が確実に解釈され、FAIL判定時にreviseステップが実行されるようにする
- **副次目的**: リトライ上限を超えても解決しない場合、後続フェーズに進まずジョブを終了する

### ビジネス価値
- **品質保証の強化**: レビューサイクルが機能することで、コード品質が向上
- **自動修正の信頼性向上**: reviseステップが確実に実行され、自動修正サイクルが正常に機能
- **コスト削減**: 後続フェーズで問題が発覚するリスクを減らし、手戻りコストを削減

### 技術的価値
- **LLMレスポンスの堅牢性**: 予期しないLLMレスポンス形式に対応
- **フォールバック機構の改善**: JSON以外の形式でも正確に判定結果を抽出
- **エラーハンドリングの強化**: リトライ制御とフェーズ失敗処理の統合

---

## 2. 機能要件

### FR-1: JSON抽出前処理の実装（最優先）

**優先度**: 高

**説明**: LLMレスポンスからJSON部分のみを抽出する前処理を追加し、JSON後の余計なテキストによる`JSON.parse()`失敗を防ぐ。

**詳細仕様**:
- 正規表現 `\{[\s\S]*?\}` でJSON部分を抽出
- 最初の `{` から最後の `}` までをマッチ
- ネストされた `{}` にも対応（非貪欲マッチ `*?`）
- 抽出失敗時はフォールバック判定ロジックに移行

**入力**: LLMレスポンス全文（文字列）
**出力**: 抽出されたJSON文字列 または `null`（抽出失敗時）

**エッジケース**:
- JSON後に空白、改行、説明文が含まれる場合
- JSON前にプレフィックステキストがある場合（例: "結果: {"）
- 複数のJSONブロックが含まれる場合（最初のものを優先）

---

### FR-2: フォールバック判定ロジックの改善（高優先）

**優先度**: 高

**説明**: `JSON.parse()` 失敗時のフォールバック処理で、明確なマーカーパターンを優先的に検出し、「PASS判定が可能になります」等の誤検出を防ぐ。

**詳細仕様**:
- **マーカーパターン優先順位**（上から順にマッチング）:
  1. `最終判定[:：]\s*(PASS|FAIL|PASS_WITH_SUGGESTIONS)`
  2. `判定結果[:：]\s*(PASS|FAIL|PASS_WITH_SUGGESTIONS)`
  3. `判定[:：]\s*(PASS|FAIL|PASS_WITH_SUGGESTIONS)`
  4. `\*\*結果[:：]?\*\*\s*(PASS|FAIL|PASS_WITH_SUGGESTIONS)`
  5. `DECISION[:：]\s*(PASS|FAIL|PASS_WITH_SUGGESTIONS)`
- いずれもマッチしない場合、**デフォルトでFAIL判定**（安全側に倒す）
- 既存の `includes('PASS')` ロジックは削除

**入力**: LLMレスポンス全文（文字列）
**出力**: 判定結果（'PASS' | 'FAIL' | 'PASS_WITH_SUGGESTIONS'）

**エッジケース**:
- 「PASS判定が可能になります」を含む文字列（FAILと判定すべき）
- 「最終判定」と「判定」の両方が含まれる場合（最終判定を優先）
- 大文字・小文字混在（case-insensitiveで処理）

---

### FR-3: リトライ上限処理の強化（中優先）

**優先度**: 中

**説明**: リトライ回数が上限（3回）を超えても FAIL 判定の場合、フェーズステータスを `failed` に更新し、後続フェーズに進まないようにする。

**詳細仕様**:
- `review-cycle-manager.ts` でリトライ回数をチェック
- リトライ上限（3回）超過時:
  - `metadata.json` の `phases.<phase>.status` を `failed` に更新
  - `metadata.json` の `phases.<phase>.retry_count` を記録
  - フェーズ失敗メッセージをログ出力
  - 後続フェーズの実行をスキップ（`phase-runner.ts` で制御）

**入力**: リトライ回数、レビュー結果
**出力**: フェーズステータス更新、ジョブ終了

**エッジケース**:
- リトライ2回目でPASS → 成功として次フェーズに進む
- リトライ3回すべてFAIL → フェーズを `failed` に、ジョブを終了

---

### FR-4: レビュー結果パース処理の統合

**優先度**: 高

**説明**: FR-1とFR-2を統合し、レビュー結果パース処理全体を1つのメソッドとして実装。

**処理フロー**:
1. **JSON抽出前処理**（FR-1）を実行
2. 抽出成功 → `JSON.parse()` を実行
3. パース成功 → 結果を返す
4. パース失敗 または 抽出失敗 → **フォールバック判定**（FR-2）を実行
5. フォールバック判定結果を返す

**入力**: LLMレスポンス全文（文字列）
**出力**: `{ result: 'PASS' | 'FAIL' | 'PASS_WITH_SUGGESTIONS', feedback?: string }`

---

## 3. 非機能要件

### NFR-1: パフォーマンス要件

- **レスポンスタイム**: JSON抽出前処理およびフォールバック判定は、100ms以内に完了すること
- **正規表現の効率**: ReDoS（Regular Expression Denial of Service）攻撃を防ぐため、非貪欲マッチ `*?` を使用
- **メモリ使用量**: LLMレスポンス（最大10MB想定）の処理で、メモリリークがないこと

### NFR-2: セキュリティ要件

- **入力検証**: LLMレスポンスに含まれる可能性のある特殊文字（`\n`, `\r`, `\t`）を適切に処理
- **ReDoS対策**: 正規表現パターンが指数的なバックトラックを引き起こさないこと（OWASP CWE-1333準拠）
- **ログマスキング**: 機密情報（APIキー等）がログに出力されないこと（既存のSecretMasker統合）

### NFR-3: 可用性・信頼性要件

- **既存テストの互換性**: 既存のすべてのテストがパスすること
- **後方互換性**: 正常なレビュー結果（正しいJSON形式）が誤ってFAIL判定されないこと
- **フォールバック保証**: JSON抽出失敗時も必ず判定結果を返すこと（デフォルト: FAIL）

### NFR-4: 保守性・拡張性要件

- **コードコメント**: JSON抽出前処理とフォールバック判定ロジックにJSDocコメントを追加
- **テストカバレッジ**: 修正箇所のテストカバレッジが90%以上であること
- **エッジケーステスト**: JSON後に余計なテキストがある場合、FAIL誤検出防止の各パターンをテスト

---

## 4. 制約事項

### 技術的制約

1. **既存コードの拡張のみ**: 新規ファイル作成なし（`content-parser.ts`、`review-cycle-manager.ts`、`phase-runner.ts`の修正のみ）
2. **アーキテクチャ変更なし**: レビューサイクルの基本フロー（execute → review → revise）は維持
3. **外部ライブラリ追加なし**: Node.js標準ライブラリのみ使用（`package.json`変更なし）
4. **LLMレスポンス形式の制御不可**: LLM（Claude Agent / Codex Agent）のレスポンス形式は制御できないため、多様な形式に対応する必要あり

### リソース制約

1. **工数**: 8~12時間（Planning Phaseで見積もり済み）
2. **優先度**: 通常（次期リリースに含める）
3. **リスク**: 中（LLMレスポンス形式の多様性、後方互換性リスク）

### ポリシー制約

1. **コーディング規約**: CLAUDE.mdに従う
   - `process.env` への直接アクセス禁止（`config.getXxx()` を使用）
   - `console.log` 禁止（`logger.info()` を使用）
   - `as Error` 型アサーション禁止（`getErrorMessage()` を使用）
2. **テスト必須**: ユニットテスト + インテグレーションテストの追加
3. **ドキュメント更新**: CLAUDE.mdの「レビュー結果パースロジック」セクションを更新

---

## 5. 前提条件

### システム環境

- **Node.js**: 20以上
- **TypeScript**: 5.x
- **Jest**: テストフレームワーク（ES modules対応）

### 依存コンポーネント

- **`src/core/content-parser.ts`**: レビュー結果パース処理の中核
- **`src/phases/core/review-cycle-manager.ts`**: レビューサイクル管理
- **`src/phases/lifecycle/phase-runner.ts`**: フェーズライフサイクル管理
- **`src/core/metadata-manager.ts`**: メタデータ更新（`phases.<phase>.status`、`retry_count`）

### 外部システム連携

- **LLM（Claude Agent / Codex Agent）**: レビュー結果の生成元（レスポンス形式は制御不可）
- **GitHub API**: 進捗コメント投稿（既存機能、本Issue修正では変更なし）

---

## 6. 受け入れ基準

### AC-1: JSON抽出前処理が正しく動作する

**Given**: LLMレスポンスが `{"result": "FAIL"} \n理由: タスク分割が不十分...` の形式で返される

**When**: `parseReviewResult()` メソッドを呼び出す

**Then**:
- JSON部分 `{"result": "FAIL"}` のみが抽出される
- `JSON.parse()` が成功し、`{ result: 'FAIL' }` が返される
- ログに「JSON抽出成功」メッセージが出力される

---

### AC-2: FAIL誤検出が防止される

**Given**: LLMレスポンスに「再度レビューを実施し、PASS判定が可能になります」が含まれ、かつ「最終判定: FAIL」が含まれる

**When**: `parseReviewResult()` メソッドを呼び出す

**Then**:
- フォールバック判定で「最終判定: FAIL」が優先される
- `{ result: 'FAIL' }` が返される
- ログに「フォールバック判定: FAIL（マーカーパターン: 最終判定）」メッセージが出力される

---

### AC-3: マーカーパターン優先順位が正しい

**Given**: LLMレスポンスに「判定: PASS」と「最終判定: FAIL」の両方が含まれる

**When**: `parseReviewResult()` メソッドを呼び出す

**Then**:
- 「最終判定: FAIL」が優先される（優先順位1位）
- `{ result: 'FAIL' }` が返される

---

### AC-4: FAIL判定時にreviseステップが実行される

**Given**: Planning Phaseのreviewステップが「FAIL」判定を返す

**When**: Planning Phaseの実行が継続される

**Then**:
- `revise()` メソッドが呼び出される
- ログに「Phase planning: Starting revise step」メッセージが出力される
- `metadata.json` の `phases.planning.current_step` が `revise` に更新される

---

### AC-5: リトライ上限超過時にフェーズが失敗する

**Given**: Planning Phaseのreviseステップが3回実行され、すべてFAIL判定

**When**: 3回目のrevise後にreviewステップが実行される

**Then**:
- `metadata.json` の `phases.planning.status` が `failed` に更新される
- `metadata.json` の `phases.planning.retry_count` が `3` に記録される
- ログに「Phase planning: Retry limit exceeded (3/3). Marking phase as failed.」メッセージが出力される
- Requirements Phase（後続フェーズ）が実行されない

---

### AC-6: リトライ上限超過時にジョブが終了する

**Given**: Planning Phaseが `failed` ステータス

**When**: `--phase all` で実行される

**Then**:
- Requirements Phase（Phase 1）の実行がスキップされる
- ログに「Skipping subsequent phases due to failed phase: planning」メッセージが出力される
- ジョブがステータスコード 1（エラー）で終了する

---

### AC-7: 既存テストがすべてパスする

**Given**: 修正後のコードベース

**When**: `npm test` を実行

**Then**:
- すべての既存テストがパスする
- テストカバレッジが90%以上である
- エラー・警告が出力されない

---

### AC-8: 新規テストケースが追加されている

**Given**: `tests/unit/core/content-parser.test.ts`

**When**: テストスイートを確認

**Then**:
- 以下のテストケースが追加されている:
  1. JSON後に余計なテキストがある場合のパーステスト
  2. 「PASS判定が可能になります」を含む文字列のFAIL判定テスト
  3. マーカーパターン優先順位のテスト（「最終判定」 > 「判定結果」）
  4. デフォルトFAIL判定テスト（マーカーパターン不在時）

---

## 7. スコープ外

### 将来的な拡張候補

1. **LLMプロンプトの改善**: レビュー結果の形式をより厳格に指定（本Issueではフォールバック機構で対応）
2. **複数LLMの対応**: Claude / Codex 以外のLLM（GPT-4o, Gemini等）のレスポンス形式対応
3. **レビュー結果のバリデーション強化**: JSONスキーマバリデーション（JSON Schema）導入
4. **リトライ回数のカスタマイズ**: 環境変数またはCLIオプションでリトライ上限を変更可能にする

### 明確にスコープ外とする事項

1. **LLMモデルの変更**: Claude / Codex のモデルバージョン変更（本Issue修正では現行モデルのまま）
2. **UI/UX改善**: GitHub Issue コメントの表示形式改善（本Issue修正ではロジック修正のみ）
3. **他フェーズのレビュー機能**: Requirements Phase、Design Phase等の他フェーズのレビュー機能は別Issue（既存機能のため、本Issueでは変更なし）
4. **メタデータスキーマ変更**: `metadata.json` の構造変更（本Issue修正では既存スキーマのまま）

---

## 付録: エッジケース一覧

Planning Phaseで洗い出されたエッジケースを再掲します。

### JSON抽出のエッジケース

| ケース | 入力例 | 期待される動作 |
|--------|--------|----------------|
| JSON後に説明文 | `{"result": "FAIL"} 理由: ...` | JSON部分のみ抽出 → パース成功 |
| JSON後に句読点 | `{"result": "FAIL"}。` | JSON部分のみ抽出 → パース成功 |
| JSON前にプレフィックス | `結果: {"result": "PASS"}` | JSON部分のみ抽出 → パース成功 |
| 複数JSONブロック | `{"result": "FAIL"} {"result": "PASS"}` | 最初のJSONを抽出 → `FAIL` と判定 |
| ネストされたJSON | `{"result": "FAIL", "details": {"reason": "..."}}` | 全体を抽出 → パース成功 |

### フォールバック判定のエッジケース

| ケース | 入力例 | 期待される動作 |
|--------|--------|----------------|
| FAIL誤検出 | `PASS判定が可能になります` + `最終判定: FAIL` | 「最終判定: FAIL」を優先 → `FAIL` |
| マーカー優先順位 | `判定: PASS` + `最終判定: FAIL` | 「最終判定」を優先 → `FAIL` |
| デフォルトFAIL | `タスク分割が不十分です` | マーカー不在 → デフォルト `FAIL` |
| 大文字小文字混在 | `Final Decision: fail` | case-insensitive → `FAIL` |

---

## 変更履歴

- **2025-01-30**: 初版作成（Planning Phaseの計画書を踏まえて要件定義を実施）
