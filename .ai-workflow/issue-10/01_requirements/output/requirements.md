# 要件定義書 - Issue #10: Git コミット頻度とレジューム粒度の改善

## 0. Planning Document の確認

Planning Phase で策定された以下の戦略を踏まえて要件定義を実施します：

### 実装戦略
- **EXTEND**: 既存のワークフローインフラ（BasePhase、MetadataManager、GitManager）を拡張
- 新規クラスではなく、既存クラスにステップ管理機能を追加

### テスト戦略
- **UNIT_INTEGRATION**: ステップ管理機能の単体テストと実際のワークフロー実行での統合テスト

### テストコード戦略
- **BOTH_TEST**: 既存テストファイルの拡張と新規テストファイルの作成

### 見積もり工数
- **20~28時間**（8フェーズ）

### リスク評価
- **高**: 既存ワークフローへの影響、CI/CD環境対応、メタデータマイグレーション

---

## 1. 概要

### 背景

現在のAI Workflowは、各フェーズ（planning、requirements、designなど）の完了後に1回だけGitコミットを実行し、レジューム機能もフェーズ単位で動作します。この粒度の粗さにより、以下の非効率が発生しています：

1. **Review失敗時の無駄な再実行**: execute()で15分かけて成果物を生成した後、review()で失敗すると、レジューム時にexecute()から再実行される
2. **Revise失敗時の大きなロス**: Implementation Phaseなどでexecute()（30分）とreview()（5分）が成功後、revise()で失敗すると全体を再実行
3. **CI/CD環境での高コスト**: Jenkins等のCI環境では各ビルドでワークスペースがリセットされ、フェーズ単位の再実行はトークン消費量と実行時間を大幅に増加させる

### 目的

execute / review / revise の各ステップ後にGitコミット＆プッシュを実行し、ステップ単位でのレジュームを可能にすることで、以下を実現します：

1. **実行時間の削減**: 失敗したステップのみを再実行することで、無駄な処理を排除
2. **コスト削減**: Claude API呼び出しの重複実行を防ぎ、トークン消費量を最小化
3. **CI/CD効率化**: Jenkins等の環境でワークスペースリセット後も、リモートから最新状態を取得して適切なステップから再開

### ビジネス価値

- **開発者体験の向上**: レジューム時の待ち時間短縮（最大30分以上の削減見込み）
- **運用コストの削減**: API呼び出し回数の削減による直接的なコスト削減
- **CI/CDパイプラインの安定化**: 部分的な失敗からの高速リカバリー

### 技術的価値

- **粒度の細分化**: フェーズ単位からステップ単位への進化
- **メタデータの充実**: current_step、completed_stepsによる詳細な状態管理
- **リモート同期の強化**: CI環境でのリモートブランチとの連携強化

---

## 2. 機能要件

### FR-1: ステップ単位のGitコミット＆プッシュ

**優先度**: 高

**説明**: execute、review、reviseの各ステップ完了後に、自動的にGitコミット＆プッシュを実行する。

**詳細仕様**:

1. **コミットメッセージ形式**:
   ```
   [ai-workflow] Phase {phase_number} ({phase_name}) - {step} completed

   Issue: #{issue_number}
   Phase: {phase_number} ({phase_name})
   Step: {step}
   Status: completed

   Auto-generated by AI Workflow
   ```

2. **コミット対象**:
   - ステップの成果物（output/ディレクトリ配下）
   - メタデータ（metadata.json）
   - ステップのログファイル（execute/、review/、revise/ディレクトリ配下）

3. **プッシュ動作**:
   - コミット成功後、即座にリモートブランチへプッシュ
   - プッシュ失敗時は最大3回リトライ（既存のpushToRemote()機能を活用）
   - 3回のリトライでも失敗した場合、ステップは未完了として記録

4. **実行タイミング**:
   - execute()メソッド完了後
   - review()メソッド完了後（レビューが実施される場合）
   - revise()メソッド完了後（修正が実施される場合）

**検証条件**:
- コミットログに正しいメッセージが記録される
- リモートブランチにコミットがプッシュされる
- metadata.jsonがコミットに含まれる

---

### FR-2: メタデータスキーマの拡張

**優先度**: 高

**説明**: metadata.jsonのPhaseMetadataインターフェースに、ステップ管理用のフィールドを追加する。

**詳細仕様**:

1. **新規フィールド**:
   ```typescript
   interface PhaseMetadata {
     status: 'pending' | 'in_progress' | 'completed' | 'failed';
     current_step?: 'execute' | 'review' | 'revise' | null;
     completed_steps: ('execute' | 'review' | 'revise')[];
     retry_count: number; // 既存
     output_files: Record<string, string>; // 既存
     // ... その他既存フィールド
   }
   ```

2. **フィールドの意味**:
   - `current_step`: 現在実行中のステップ（実行中でない場合はnull）
   - `completed_steps`: 完了済みステップの配列（実行順序を保持）

3. **メタデータ更新タイミング**:
   - **ステップ開始前**: `current_step`を更新（例: "execute"）
   - **ステップ完了後**: `completed_steps`に追加、`current_step`をnullに設定
   - **フェーズ完了後**: `status`を"completed"に、`current_step`をnullに設定

4. **メタデータの保存**:
   - 各ステップのGitコミットに含めてプッシュ
   - リモートブランチから常に最新状態を取得可能

**検証条件**:
- TypeScriptの型定義が正しく更新される
- メタデータの読み書きが正常に動作する
- 既存のメタデータ構造との互換性が保たれる

---

### FR-3: ステップ単位のレジューム機能

**優先度**: 高

**説明**: ワークフロー再開時に、metadata.jsonのcurrent_stepとcompleted_stepsを基に、適切なステップから処理を再開する。

**詳細仕様**:

1. **レジューム判定ロジック**:
   - リモートブランチから最新状態をpull（CI環境）
   - metadata.jsonを読み込み
   - `completed_steps`に含まれるステップはスキップ
   - `current_step`がnull以外の場合、そのステップから再開
   - `current_step`がnullの場合、次のステップ（completed_stepsに含まれない最初のステップ）から開始

2. **ステップスキップ処理**:
   ```typescript
   if (metadata.completed_steps.includes('execute')) {
     console.log('Skipping execute step (already completed)');
   } else {
     await this.execute(context);
     // コミット＆プッシュ
   }
   ```

3. **CI環境での動作**:
   ```
   Jenkins Build #1:
   ├── execute() ✅ → コミット＆プッシュ成功
   ├── review() ❌ 失敗
   └── ビルド終了（ワークスペース削除）

   Jenkins Build #2（レジューム）:
   ├── git pull（最新状態を取得）
   ├── metadata.json読み込み（current_step: "review", completed_steps: ["execute"]）
   ├── execute() ⏭️ スキップ
   └── review() 🔄 再実行
   ```

4. **エラーハンドリング**:
   - メタデータ不整合時（current_stepとcompleted_stepsの矛盾）は警告を表示し、安全側（最初から再実行）にフォールバック
   - リモートブランチが存在しない場合は通常の新規実行として扱う

**検証条件**:
- execute完了後のレジュームでexecuteがスキップされる
- review失敗後のレジュームでreviewから再開される
- CI環境でリモート同期が正常に動作する

---

### FR-4: プッシュ失敗時のエラーハンドリング

**優先度**: 高

**説明**: Gitプッシュ失敗時に適切にリトライを実行し、全て失敗した場合はステップを未完了として記録する。

**詳細仕様**:

1. **リトライ動作**:
   - コミット成功後、`pushToRemote()`を実行（既存機能）
   - プッシュ失敗時、最大3回リトライ（指数バックオフ: 1秒、2秒、4秒）
   - 各リトライ前にリモートから最新状態をpullして競合を解決

2. **成功時の処理**:
   - ステップ完了として`completed_steps`に追加
   - `current_step`をnullに設定
   - 次のステップへ進行

3. **失敗時の処理**:
   - ステップ未完了として`current_step`を維持
   - エラーメッセージをログに記録
   - フェーズの`status`を"failed"に設定
   - 次回レジューム時、同じステップを最初から再実行

4. **CI環境での重要性**:
   - CI環境ではローカルコミットはワークスペースリセットで消失
   - プッシュ成功が進捗保存の唯一の手段
   - プッシュ失敗時は明確なエラーメッセージで開発者に通知

**検証条件**:
- プッシュ成功時にステップが完了として記録される
- プッシュ失敗時にステップが未完了として記録される
- リトライが最大3回実行される

---

### FR-5: BasePhase.run()メソッドの修正

**優先度**: 高

**説明**: BasePhaseの`run()`メソッドを修正し、各ステップ後にコミット＆プッシュを実行するように変更する。

**詳細仕様**:

1. **既存のrun()メソッド**（現在）:
   ```typescript
   async run(options) {
     await this.execute(context);
     if (this.hasReview) {
       await this.review(context);
       if (reviewFailed) {
         await this.revise(context);
       }
     }
     // フェーズ完了後に1回だけコミット＆プッシュ
     if (gitManager) {
       await gitManager.commitPhaseOutput(...);
     }
   }
   ```

2. **新しいrun()メソッド**（修正後）:
   ```typescript
   async run(options) {
     // Execute step
     if (!metadata.completed_steps.includes('execute')) {
       metadata.current_step = 'execute';
       await metadataManager.save(metadata);

       await this.execute(context);

       await this.commitAndPushStep('execute', ...);
       metadata.completed_steps.push('execute');
       metadata.current_step = null;
       await metadataManager.save(metadata);
     }

     // Review step
     if (this.hasReview && !metadata.completed_steps.includes('review')) {
       metadata.current_step = 'review';
       await metadataManager.save(metadata);

       const reviewResult = await this.review(context);

       await this.commitAndPushStep('review', ...);
       metadata.completed_steps.push('review');
       metadata.current_step = null;
       await metadataManager.save(metadata);

       // Revise step (if needed)
       if (reviewFailed && !metadata.completed_steps.includes('revise')) {
         metadata.current_step = 'revise';
         await metadataManager.save(metadata);

         await this.revise(context);

         await this.commitAndPushStep('revise', ...);
         metadata.completed_steps.push('revise');
         metadata.current_step = null;
         await metadataManager.save(metadata);
       }
     }

     // フェーズ完了
     metadata.status = 'completed';
     await metadataManager.save(metadata);
   }
   ```

3. **commitAndPushStep()メソッド**（新規追加）:
   ```typescript
   private async commitAndPushStep(
     step: 'execute' | 'review' | 'revise',
     context: ExecutionContext
   ): Promise<void> {
     const message = this.buildStepCommitMessage(step, context);
     await gitManager.commitStepOutput(message, context);

     try {
       await gitManager.pushToRemote(context.branchName, 3); // 最大3回リトライ
     } catch (error) {
       // プッシュ失敗時の処理
       throw new Error(`Failed to push step ${step}: ${error.message}`);
     }
   }
   ```

**検証条件**:
- 各ステップ後にコミット＆プッシュが実行される
- ステップスキップロジックが正常に動作する
- エラー時に適切に例外がスローされる

---

### FR-6: GitManagerの拡張

**優先度**: 高

**説明**: GitManagerに、ステップ単位のコミットを実行する機能を追加する。

**詳細仕様**:

1. **新規メソッド**: `commitStepOutput()`
   ```typescript
   async commitStepOutput(
     phaseName: string,
     phaseNumber: number,
     step: 'execute' | 'review' | 'revise',
     issueNumber: number,
     workingDir: string
   ): Promise<void> {
     const message = this.buildStepCommitMessage(
       phaseName, phaseNumber, step, issueNumber
     );

     await this.git.add('.ai-workflow/**/*');
     await this.git.commit(message);
   }
   ```

2. **コミットメッセージ生成**: `buildStepCommitMessage()`
   ```typescript
   private buildStepCommitMessage(
     phaseName: string,
     phaseNumber: number,
     step: string,
     issueNumber: number
   ): string {
     return `[ai-workflow] Phase ${phaseNumber} (${phaseName}) - ${step} completed

Issue: #${issueNumber}
Phase: ${phaseNumber} (${phaseName})
Step: ${step}
Status: completed

Auto-generated by AI Workflow`;
   }
   ```

3. **既存メソッドとの関係**:
   - `commitPhaseOutput()`は引き続き存在（後方互換性のため）
   - 新しいワークフローでは`commitStepOutput()`を使用
   - 既存のワークフローは影響を受けない

**検証条件**:
- コミットメッセージが正しい形式で生成される
- ステップの成果物が正しくコミットされる
- 既存のcommitPhaseOutput()が引き続き動作する

---

### FR-7: ResumeManagerの拡張

**優先度**: 中

**説明**: ResumeManagerに、ステップ単位でのレジューム判定機能を追加する。

**詳細仕様**:

1. **新規メソッド**: `getResumeStep()`
   ```typescript
   getResumeStep(phaseName: string, metadata: WorkflowState): {
     shouldResume: boolean;
     resumeStep: 'execute' | 'review' | 'revise' | null;
     completedSteps: string[];
   } {
     const phaseMetadata = metadata.phases[phaseName];

     if (!phaseMetadata || phaseMetadata.status === 'pending') {
       return { shouldResume: false, resumeStep: null, completedSteps: [] };
     }

     if (phaseMetadata.status === 'completed') {
       return { shouldResume: false, resumeStep: null, completedSteps: phaseMetadata.completed_steps };
     }

     // in_progress または failed
     const resumeStep = phaseMetadata.current_step || this.getNextStep(phaseMetadata.completed_steps);
     return {
       shouldResume: true,
       resumeStep,
       completedSteps: phaseMetadata.completed_steps
     };
   }
   ```

2. **次ステップ判定**: `getNextStep()`
   ```typescript
   private getNextStep(completedSteps: string[]): 'execute' | 'review' | 'revise' {
     if (!completedSteps.includes('execute')) return 'execute';
     if (!completedSteps.includes('review')) return 'review';
     if (!completedSteps.includes('revise')) return 'revise';
     return 'execute'; // フォールバック
   }
   ```

3. **CI環境対応**:
   - `getResumeStep()`呼び出し前にリモートブランチからpull
   - metadata.jsonの同期を保証

**検証条件**:
- 正しいステップから再開される
- completed_stepsが正しく解釈される
- エッジケース（メタデータ不整合）で安全にフォールバックする

---

### FR-8: メタデータマイグレーション処理

**優先度**: 中

**説明**: 既存のmetadata.jsonに対して、新しいスキーマへのマイグレーション処理を実装する。

**詳細仕様**:

1. **マイグレーション対象**:
   - 既存のmetadata.json（current_step、completed_stepsフィールドなし）

2. **マイグレーションロジック**:
   ```typescript
   function migrateMetadata(metadata: WorkflowState): WorkflowState {
     for (const [phaseName, phaseData] of Object.entries(metadata.phases)) {
       if (!phaseData.completed_steps) {
         // completed フェーズ
         if (phaseData.status === 'completed') {
           phaseData.completed_steps = ['execute', 'review', 'revise'];
           phaseData.current_step = null;
         }
         // in_progress フェーズ
         else if (phaseData.status === 'in_progress') {
           phaseData.completed_steps = [];
           phaseData.current_step = 'execute';
         }
         // pending または failed
         else {
           phaseData.completed_steps = [];
           phaseData.current_step = null;
         }
       }
     }
     return metadata;
   }
   ```

3. **実行タイミング**:
   - MetadataManager.load()メソッド内で自動的に実行
   - マイグレーション後、metadata.jsonを保存

4. **バックアップ**:
   - マイグレーション前に`metadata.json.backup`を作成
   - マイグレーション失敗時にロールバック可能

**検証条件**:
- 既存のメタデータが正しく新スキーマに変換される
- マイグレーション後も既存ワークフローが動作する
- バックアップが正しく作成される

---

## 3. 非機能要件

### NFR-1: パフォーマンス

**優先度**: 中

**要件**:
- ステップ単位のGitコミット＆プッシュによるオーバーヘッドは、フェーズ全体の実行時間の5%以内に抑える
- メタデータ読み書きの遅延は100ms以内
- プッシュのリトライによる遅延は、1回あたり最大7秒（1秒+2秒+4秒）

**測定方法**:
- フェーズ実行前後の時間を計測
- コミット＆プッシュの時間を個別に計測
- オーバーヘッド率を算出（コミット時間 / フェーズ全体時間）

---

### NFR-2: 信頼性

**優先度**: 高

**要件**:
- プッシュ失敗時のリトライ成功率: 95%以上（ネットワーク一時障害を想定）
- メタデータ不整合によるワークフロー停止: 0件（フォールバック機能により継続）
- CI環境でのレジューム成功率: 99%以上

**エラーハンドリング**:
- すべての例外を適切にキャッチし、ログに記録
- ユーザーに分かりやすいエラーメッセージを表示
- 致命的でないエラーは警告として扱い、処理を継続

---

### NFR-3: 保守性

**優先度**: 中

**要件**:
- 既存のコードベースとの整合性を保つ
- TypeScriptの型定義を厳格に適用（`strict: true`）
- ログメッセージは構造化され、検索・フィルタリングが容易
- ドキュメント（CLAUDE.md、ARCHITECTURE.md）を更新

**コーディング規約**:
- ESLintルールに準拠
- メソッド名は動詞で始める（例: `commitStepOutput`、`getResumeStep`）
- 複雑なロジックにはコメントを追加

---

### NFR-4: 拡張性

**優先度**: 低

**要件**:
- 将来的にステップ種別を追加可能（例: "validate"、"deploy"）
- 他のGitホスティングサービス（GitLab、Bitbucket）への拡張を考慮
- カスタムコミットメッセージフォーマットのサポート

---

### NFR-5: セキュリティ

**優先度**: 中

**要件**:
- Gitコミットに機密情報（APIキー、パスワード）を含めない
- プッシュ失敗時のエラーメッセージに認証情報を含めない
- メタデータの書き込み権限を適切に制限

---

## 4. 制約事項

### 技術的制約

1. **既存アーキテクチャの維持**:
   - BasePhase、MetadataManager、GitManagerの既存インターフェースを可能な限り保持
   - 既存のワークフローに影響を与えない後方互換性の確保

2. **Git操作の制約**:
   - `simple-git`ライブラリの機能範囲内で実装
   - リモートリポジトリの権限（push権限）が必要
   - ブランチ保護ルール（force pushの禁止）に準拠

3. **CI/CD環境の制約**:
   - Jenkinsワークスペースは各ビルド後にリセットされる
   - リモートブランチが唯一の永続化手段
   - 環境変数（`GITHUB_TOKEN`、`GIT_COMMIT_USER_NAME`など）に依存

4. **TypeScript/Node.jsの制約**:
   - Node.js 20以上
   - TypeScript strict modeに準拠
   - ES Modulesの使用

---

### リソース制約

1. **時間**: 見積もり工数20~28時間（Planning Documentより）
2. **開発者**: 1名（AIエージェント + レビュアー）
3. **テスト環境**: ローカル環境 + Jenkins CI環境

---

### ポリシー制約

1. **コーディング規約**: CLAUDE.mdに記載のガイドラインに準拠
2. **コミットメッセージ**: `[ai-workflow]`プレフィックスを使用
3. **ブランチ戦略**: `ai-workflow/issue-{issue_number}`形式のブランチ名
4. **レビュープロセス**: すべてのフェーズでクリティカルシンキングレビューを実施

---

## 5. 前提条件

### システム環境

1. **Node.js**: 20以上
2. **npm**: 10以上
3. **Git**: 2.30以上
4. **TypeScript**: 5.x

### 依存コンポーネント

1. **simple-git**: Git操作ライブラリ
2. **@octokit/rest**: GitHub API クライアント
3. **fs-extra**: ファイルシステム操作
4. **Jest**: テストフレームワーク

### 外部システム連携

1. **GitHub**: リモートリポジトリ、Issue、PR
2. **Jenkins**: CI/CDパイプライン（オプション）
3. **Claude/Codex API**: AIエージェント

### 環境変数

1. **必須**:
   - `GITHUB_TOKEN`: GitHub パーソナルアクセストークン
   - `GITHUB_REPOSITORY`: `owner/repo`形式

2. **オプション**:
   - `GIT_COMMIT_USER_NAME`: Gitコミット作成者名
   - `GIT_COMMIT_USER_EMAIL`: Gitコミット作成者メール
   - `REPOS_ROOT`: マルチリポジトリ環境のルートディレクトリ

---

## 6. 受け入れ基準

### AC-1: Execute ステップ後のGitコミット＆プッシュ

**Given**: Requirements PhaseのExecuteステップが完了した
**When**: ワークフローを実行する
**Then**: 以下が確認できる
- ローカルブランチに`[ai-workflow] Phase 1 (requirements) - execute completed`というコミットが存在
- リモートブランチ（`origin/ai-workflow/issue-123`）にも同じコミットが存在
- コミットに`.ai-workflow/issue-123/metadata.json`が含まれる

**検証コマンド**:
```bash
git log -1 --oneline
# Expected: [ai-workflow] Phase 1 (requirements) - execute completed

git log origin/ai-workflow/issue-123 -1 --oneline
# Expected: [ai-workflow] Phase 1 (requirements) - execute completed
```

---

### AC-2: Review ステップ後のGitコミット＆プッシュ

**Given**: Requirements PhaseのReviewステップが完了した
**When**: ワークフローを実行する
**Then**: 以下が確認できる
- ローカルブランチに`[ai-workflow] Phase 1 (requirements) - review completed`というコミットが存在
- リモートブランチにも同じコミットが存在

**検証コマンド**:
```bash
git log -1 --oneline
# Expected: [ai-workflow] Phase 1 (requirements) - review completed
```

---

### AC-3: Revise ステップ後のGitコミット＆プッシュ

**Given**: Requirements PhaseのReviseステップが完了した（レビュー失敗時のみ）
**When**: ワークフローを実行する
**Then**: 以下が確認できる
- ローカルブランチに`[ai-workflow] Phase 1 (requirements) - revise completed`というコミットが存在
- リモートブランチにも同じコミットが存在

**検証コマンド**:
```bash
git log -1 --oneline
# Expected: [ai-workflow] Phase 1 (requirements) - revise completed
```

---

### AC-4: メタデータにcurrent_stepが記録され、リモートにプッシュされる

**Given**: Execute ステップが完了し、Reviewステップが開始された
**When**: リモートブランチからメタデータを取得する
**Then**: 以下のメタデータが確認できる

```json
{
  "phases": {
    "requirements": {
      "status": "in_progress",
      "current_step": "review",
      "completed_steps": ["execute"],
      "output_files": {
        "execute": ".ai-workflow/issue-123/01_requirements/output/requirements.md"
      }
    }
  }
}
```

**検証コマンド**:
```bash
git pull origin ai-workflow/issue-123
cat .ai-workflow/issue-123/metadata.json | jq '.phases.requirements'
```

---

### AC-5: Execute完了後のレジューム（CI環境）

**Given**: Jenkins Build #1でExecuteステップが完了し、Reviewステップで失敗した
**When**: Jenkins Build #2でワークフローを再実行する
**Then**: 以下が確認できる
- Executeステップがスキップされる（"Skipping execute step (already completed)"というログが表示される）
- Reviewステップから再開される
- トークン消費量がExecuteステップ分削減される

**検証方法**:
```bash
# Jenkins Build #2のログを確認
# Expected log:
# INFO: Resuming phase 'requirements' from step 'review'
# INFO: Skipping execute step (already completed)
# INFO: Running review step...
```

---

### AC-6: プッシュ失敗後の動作

**Given**: Executeステップでコミットは成功したが、プッシュが3回のリトライでも失敗した
**When**: ワークフローを再実行する
**Then**: 以下が確認できる
- ステップが未完了として記録される（`current_step: "execute"`、`completed_steps: []`）
- エラーメッセージ「Failed to push step execute: ...」が表示される
- 次回レジューム時、Executeステップが最初から再実行される

**検証方法**:
```bash
cat .ai-workflow/issue-123/metadata.json | jq '.phases.requirements'
# Expected:
{
  "status": "failed",
  "current_step": "execute",
  "completed_steps": []
}
```

---

### AC-7: フェーズ完了後のGitログ

**Given**: Requirements Phaseがすべてのステップ（Execute、Review、Revise）を完了した
**When**: Gitログを確認する
**Then**: 以下の3つのコミットが存在する

```bash
git log --oneline -3
# Expected:
# abc1234 [ai-workflow] Phase 1 (requirements) - revise completed
# def5678 [ai-workflow] Phase 1 (requirements) - review completed
# ghi9012 [ai-workflow] Phase 1 (requirements) - execute completed
```

---

### AC-8: メタデータマイグレーション

**Given**: 古いスキーマのmetadata.json（current_step、completed_stepsフィールドなし）が存在する
**When**: ワークフローを実行する
**Then**: 以下が確認できる
- metadata.jsonが新しいスキーマに自動的にマイグレーションされる
- `metadata.json.backup`が作成される
- 既存のワークフローが引き続き動作する

**検証方法**:
```bash
# マイグレーション前
cat metadata.json
# { "phases": { "planning": { "status": "completed", "retry_count": 0 } } }

# ワークフロー実行

# マイグレーション後
cat metadata.json
# { "phases": { "planning": { "status": "completed", "retry_count": 0, "completed_steps": ["execute", "review", "revise"], "current_step": null } } }

# バックアップ確認
ls -l metadata.json.backup
```

---

### AC-9: CI環境でのリモート同期

**Given**: Jenkins環境でワークフローが実行される
**When**: 各ビルドでワークスペースがリセットされる
**Then**: 以下が確認できる
- ビルド開始時にリモートブランチから最新状態がpullされる
- metadata.jsonが正しく同期される
- 前回のビルドで完了したステップがスキップされる

**検証方法**:
```bash
# Jenkinsログを確認
# Expected log:
# INFO: Pulling latest changes from remote branch...
# INFO: Loaded metadata from .ai-workflow/issue-123/metadata.json
# INFO: Resuming from step 'review' (completed steps: ["execute"])
```

---

### AC-10: TypeScript型安全性

**Given**: PhaseMetadataインターフェースが拡張された
**When**: TypeScriptコンパイルを実行する
**Then**: 以下が確認できる
- コンパイルエラーが0件
- `current_step`、`completed_steps`フィールドに型推論が効く
- 不正な値（例: `current_step: "invalid"`）はコンパイルエラーとなる

**検証方法**:
```bash
npm run build
# Expected: ✓ Built successfully
```

---

## 7. スコープ外

以下の項目は、本Issue（#10）のスコープ外とし、将来的な拡張候補とします：

### 1. ステップ種別の追加

**内容**: execute / review / revise 以外のステップ（例: "validate"、"deploy"、"rollback"）の追加

**理由**: 既存のワークフローアーキテクチャとの整合性を保つため、現時点では既存の3ステップに限定

**将来的な拡張**: Phase 0.4.0以降で検討

---

### 2. カスタムコミットメッセージフォーマット

**内容**: ユーザーがコミットメッセージのフォーマットをカスタマイズできる機能

**理由**: 標準フォーマットで十分なユースケースをカバーできるため、現時点では不要

**将来的な拡張**: ユーザーからの要望に応じて検討

---

### 3. Git以外のバージョン管理システムのサポート

**内容**: Mercurial、SVNなどのサポート

**理由**: プロジェクトはGitHubを前提としており、他のVCSのサポートは優先度が低い

**将来的な拡張**: 要望があれば別Issueで対応

---

### 4. ステップの並列実行

**内容**: 複数のステップを並列で実行する機能

**理由**: execute → review → revise のフローは本質的にシーケンシャルであり、並列化の恩恵が少ない

**将来的な拡張**: 異なるフェーズの並列実行は別Issueで検討可能

---

### 5. ステップレベルのロールバック

**内容**: 特定のステップを取り消して前の状態に戻す機能

**理由**: 複雑度が高く、Gitの履歴管理との整合性が難しい

**将来的な拡張**: 安全なロールバック機能の設計が必要

---

### 6. リアルタイムプログレス通知

**内容**: Slack、Microsoft Teams等への各ステップ完了通知

**理由**: GitHub Issueへのコメント投稿機能で基本的なニーズは満たされている

**将来的な拡張**: Phase 0.5.0以降で通知機能全般を強化する際に検討

---

### 7. ステップの依存関係管理

**内容**: 特定のステップが他のフェーズのステップに依存する関係を定義する機能

**理由**: 現在のフェーズ依存関係で十分であり、ステップレベルの依存関係は過度に複雑

**将来的な拡張**: 複雑なワークフローが必要になった場合に検討

---

## 付録A: 用語集

| 用語 | 定義 |
|------|------|
| **Phase** | ワークフローの大きな単位（例: Planning、Requirements、Design）。0〜9の番号が付与される。 |
| **Step** | フェーズ内の処理単位。execute、review、reviseの3種類。 |
| **Execute** | フェーズの主要な成果物を生成するステップ。 |
| **Review** | Executeで生成した成果物をレビューするステップ（オプション）。 |
| **Revise** | Reviewで失敗した場合に自動修正を行うステップ（オプション、最大3回）。 |
| **Metadata** | ワークフローの状態を記録するJSON形式のデータ（`.ai-workflow/issue-*/metadata.json`）。 |
| **current_step** | 現在実行中または次に実行すべきステップ。 |
| **completed_steps** | 完了済みステップの配列。 |
| **Resume** | ワークフローを中断した箇所から再開する機能。 |
| **CI環境** | Jenkins等の継続的インテグレーション環境。各ビルドでワークスペースがリセットされる。 |

---

## 付録B: 参照ドキュメント

- **Planning Document**: `.ai-workflow/issue-10/00_planning/output/planning.md`
- **CLAUDE.md**: プロジェクトの全体方針とコーディングガイドライン
- **ARCHITECTURE.md**: アーキテクチャ設計思想
- **README.md**: プロジェクト概要と使用方法
- **Issue #10**: https://github.com/tielec/ai-workflow-agent/issues/10

---

## 付録C: リスクと軽減策（Planning Documentより）

| リスク | 影響度 | 確率 | 軽減策 |
|--------|--------|------|--------|
| メタデータマイグレーション失敗 | 高 | 中 | バックアップ作成、ユニットテスト、既存ワークフローでの動作確認 |
| Gitプッシュ失敗時のワークフロー中断 | 高 | 中 | リトライ機能（最大3回）、エラーメッセージの明確化 |
| CI環境でのレジューム失敗 | 高 | 中 | リモート同期処理、CI環境での統合テスト、Jenkinsパイプラインでのテスト |
| 既存ワークフローへの影響 | 中 | 低 | 後方互換性のためのマイグレーション、既存テストの実行、段階的ロールアウト |
| パフォーマンス劣化 | 低 | 低 | オーバーヘッド測定、必要に応じてバッチ処理を検討 |

---

**作成日**: 2025-01-XX
**Issue**: #10
**Phase**: Requirements (Phase 1)
**Status**: Draft
