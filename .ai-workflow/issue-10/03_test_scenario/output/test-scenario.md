# テストシナリオ - Issue #10: Git コミット頻度とレジューム粒度の改善

## 0. テスト戦略サマリー

### 選択されたテスト戦略
**UNIT_INTEGRATION** (Phase 2で決定)

### テスト対象の範囲

1. **Unitテスト対象**:
   - MetadataManager のステップ管理メソッド
   - GitManager のコミットメッセージ生成とステップコミット機能
   - ResumeManager のステップ判定ロジック
   - WorkflowState のマイグレーション処理

2. **Integrationテスト対象**:
   - BasePhase.run() の実際のステップ実行フロー（execute → commit → review → commit → revise → commit）
   - CI環境でのリモート同期（git pull → メタデータ読み込み → ステップスキップ）
   - プッシュ失敗時のリトライ動作とリカバリー
   - メタデータマイグレーションの実際の動作

### テストの目的

1. **機能検証**: ステップ単位のコミット＆プッシュ、レジューム機能が要件通り動作することを確認
2. **信頼性検証**: プッシュ失敗時のリトライ、メタデータ不整合時のフォールバック動作を確認
3. **互換性検証**: 既存ワークフローへの影響がないこと、マイグレーションが正しく動作することを確認
4. **CI/CD対応検証**: Jenkins等のCI環境でワークスペースリセット後も正しくレジュームできることを確認

---

## 1. Unitテストシナリオ

### 1.1 MetadataManager - ステップ管理機能

#### TC-U-001: updateCurrentStep_正常系

- **目的**: current_stepフィールドが正しく更新されることを検証
- **前提条件**: MetadataManagerが初期化され、requirementsフェーズのメタデータが存在する
- **入力**:
  - phaseName: 'requirements'
  - step: 'execute'
- **期待結果**:
  - metadata.phases.requirements.current_step が 'execute' に設定される
  - metadata.jsonに変更が保存される
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress",
        "current_step": null,
        "completed_steps": []
      }
    }
  }
  ```

#### TC-U-002: updateCurrentStep_nullリセット

- **目的**: current_stepをnullにリセットできることを検証
- **前提条件**: current_stepが'execute'に設定されている
- **入力**:
  - phaseName: 'requirements'
  - step: null
- **期待結果**:
  - metadata.phases.requirements.current_step が null に設定される
- **テストデータ**: 上記TC-U-001の期待結果を入力とする

#### TC-U-003: addCompletedStep_正常系

- **目的**: completed_stepsにステップが追加されることを検証
- **前提条件**: completed_stepsが空配列
- **入力**:
  - phaseName: 'requirements'
  - step: 'execute'
- **期待結果**:
  - metadata.phases.requirements.completed_steps に 'execute' が追加される
  - metadata.phases.requirements.current_step が null にリセットされる
- **テストデータ**: TC-U-001の入力データ

#### TC-U-004: addCompletedStep_重複チェック

- **目的**: 重複したステップが追加されないことを検証（冪等性）
- **前提条件**: completed_stepsに既に'execute'が含まれている
- **入力**:
  - phaseName: 'requirements'
  - step: 'execute'
- **期待結果**:
  - completed_stepsの長さが変わらない
  - 'execute'が1つだけ存在する
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress",
        "current_step": null,
        "completed_steps": ["execute"]
      }
    }
  }
  ```

#### TC-U-005: addCompletedStep_複数ステップ

- **目的**: 複数のステップが順序通りに追加されることを検証
- **前提条件**: completed_stepsが空配列
- **入力**:
  - 1回目: phaseName='requirements', step='execute'
  - 2回目: phaseName='requirements', step='review'
  - 3回目: phaseName='requirements', step='revise'
- **期待結果**:
  - completed_steps が ['execute', 'review', 'revise'] になる
  - 実行順序が保持される
- **テストデータ**: TC-U-001の入力データ

#### TC-U-006: getCompletedSteps_空配列

- **目的**: 新規フェーズでcompleted_stepsが空配列を返すことを検証
- **前提条件**: requirementsフェーズが新規作成された
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  - 空配列 [] が返される
- **テストデータ**: TC-U-001の入力データ

#### TC-U-007: getCompletedSteps_既存ステップ

- **目的**: 完了済みステップが正しく取得できることを検証
- **前提条件**: completed_stepsに['execute', 'review']が含まれている
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  - ['execute', 'review'] が返される
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "completed_steps": ["execute", "review"]
      }
    }
  }
  ```

#### TC-U-008: getCurrentStep_null

- **目的**: ステップ実行中でない場合にnullが返されることを検証
- **前提条件**: current_stepがnull
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  - null が返される
- **テストデータ**: TC-U-001の入力データ

#### TC-U-009: getCurrentStep_実行中

- **目的**: 実行中のステップが正しく取得できることを検証
- **前提条件**: current_stepが'execute'
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  - 'execute' が返される
- **テストデータ**: TC-U-001の期待結果を入力とする

---

### 1.2 GitManager - ステップコミット機能

#### TC-U-010: buildStepCommitMessage_正常系

- **目的**: ステップコミットメッセージが正しい形式で生成されることを検証
- **前提条件**: GitManagerが初期化されている
- **入力**:
  - phaseName: 'requirements'
  - phaseNumber: 1
  - step: 'execute'
  - issueNumber: 123
- **期待結果**:
  ```
  [ai-workflow] Phase 1 (requirements) - execute completed

  Issue: #123
  Phase: 1 (requirements)
  Step: execute
  Status: completed

  Auto-generated by AI Workflow
  ```
- **テストデータ**: 上記入力パラメータ

#### TC-U-011: buildStepCommitMessage_各ステップ

- **目的**: execute/review/revise各ステップのメッセージが正しく生成されることを検証
- **前提条件**: GitManagerが初期化されている
- **入力**:
  - 共通: phaseName='requirements', phaseNumber=1, issueNumber=123
  - パターン1: step='execute'
  - パターン2: step='review'
  - パターン3: step='revise'
- **期待結果**:
  - 各ステップに対応したメッセージが生成される
  - "Step: execute/review/revise" が正しく含まれる
- **テストデータ**: 上記入力パラメータ

#### TC-U-012: commitStepOutput_正常系

- **目的**: ステップコミットが正しく作成されることを検証
- **前提条件**:
  - Gitリポジトリが初期化されている
  - .ai-workflow/issue-123/01_requirements/output/ に変更ファイルが存在
- **入力**:
  - phaseName: 'requirements'
  - phaseNumber: 1
  - step: 'execute'
  - issueNumber: 123
  - workingDir: '/tmp/workspace'
- **期待結果**:
  - CommitResult.success が true
  - CommitResult.commit_hash が null でない
  - CommitResult.files_committed に対象ファイルが含まれる
- **テストデータ**:
  - 変更ファイル: .ai-workflow/issue-123/01_requirements/output/requirements.md
  - 変更ファイル: .ai-workflow/issue-123/metadata.json

#### TC-U-013: commitStepOutput_ファイルなし

- **目的**: コミット対象ファイルがない場合の動作を検証
- **前提条件**:
  - Gitリポジトリが初期化されている
  - 変更ファイルが存在しない
- **入力**: TC-U-012と同じ
- **期待結果**:
  - CommitResult.success が true
  - CommitResult.commit_hash が null
  - CommitResult.files_committed が空配列
  - 警告ログ "[WARNING] No files to commit for step: execute" が出力される
- **テストデータ**: 変更ファイルなし

#### TC-U-014: commitStepOutput_コミット失敗

- **目的**: Gitコミット失敗時のエラーハンドリングを検証
- **前提条件**:
  - Gitリポジトリが初期化されていない（エラーを誘発）
- **入力**: TC-U-012と同じ
- **期待結果**:
  - CommitResult.success が false
  - CommitResult.error にエラーメッセージが含まれる
  - エラーログ "[ERROR] Step commit failed: ..." が出力される
- **テストデータ**: TC-U-012のテストデータ

---

### 1.3 ResumeManager - ステップ判定ロジック

#### TC-U-015: getResumeStep_新規フェーズ

- **目的**: 新規フェーズ（pending）でshouldResume=falseが返されることを検証
- **前提条件**: requirementsフェーズがpending状態
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  ```javascript
  {
    shouldResume: false,
    resumeStep: null,
    completedSteps: []
  }
  ```
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "pending"
      }
    }
  }
  ```

#### TC-U-016: getResumeStep_完了フェーズ

- **目的**: 完了済みフェーズでshouldResume=falseが返されることを検証
- **前提条件**: requirementsフェーズがcompleted状態
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  ```javascript
  {
    shouldResume: false,
    resumeStep: null,
    completedSteps: ['execute', 'review', 'revise']
  }
  ```
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "completed",
        "completed_steps": ["execute", "review", "revise"]
      }
    }
  }
  ```

#### TC-U-017: getResumeStep_current_step設定あり

- **目的**: current_stepが設定されている場合、そこから再開されることを検証
- **前提条件**:
  - status: 'in_progress'
  - current_step: 'review'
  - completed_steps: ['execute']
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  ```javascript
  {
    shouldResume: true,
    resumeStep: 'review',
    completedSteps: ['execute']
  }
  ```
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress",
        "current_step": "review",
        "completed_steps": ["execute"]
      }
    }
  }
  ```

#### TC-U-018: getResumeStep_current_stepなし

- **目的**: current_stepがnullの場合、次のステップが判定されることを検証
- **前提条件**:
  - status: 'in_progress'
  - current_step: null
  - completed_steps: ['execute']
- **入力**:
  - phaseName: 'requirements'
- **期待結果**:
  ```javascript
  {
    shouldResume: true,
    resumeStep: 'review',
    completedSteps: ['execute']
  }
  ```
- **テストデータ**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress",
        "current_step": null,
        "completed_steps": ["execute"]
      }
    }
  }
  ```

#### TC-U-019: getNextStep_ステップ未完了

- **目的**: ステップ未完了の場合にexecuteが返されることを検証
- **前提条件**: completed_stepsが空配列
- **入力**:
  - completedSteps: []
- **期待結果**:
  - 'execute' が返される
- **テストデータ**: 空配列

#### TC-U-020: getNextStep_execute完了

- **目的**: execute完了後にreviewが返されることを検証
- **前提条件**: completed_stepsに'execute'が含まれる
- **入力**:
  - completedSteps: ['execute']
- **期待結果**:
  - 'review' が返される
- **テストデータ**: ['execute']

#### TC-U-021: getNextStep_execute_review完了

- **目的**: execute、review完了後にreviseが返されることを検証
- **前提条件**: completed_stepsに['execute', 'review']が含まれる
- **入力**:
  - completedSteps: ['execute', 'review']
- **期待結果**:
  - 'revise' が返される
- **テストデータ**: ['execute', 'review']

#### TC-U-022: getNextStep_全ステップ完了

- **目的**: 全ステップ完了時のフォールバック動作を検証
- **前提条件**: completed_stepsに['execute', 'review', 'revise']が含まれる
- **入力**:
  - completedSteps: ['execute', 'review', 'revise']
- **期待結果**:
  - 'execute' が返される（フォールバック）
- **テストデータ**: ['execute', 'review', 'revise']

---

### 1.4 WorkflowState - マイグレーション処理

#### TC-U-023: migrate_current_step追加

- **目的**: 古いスキーマにcurrent_stepフィールドが追加されることを検証
- **前提条件**: metadata.jsonにcurrent_stepフィールドが存在しない
- **入力**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress"
      }
    }
  }
  ```
- **期待結果**:
  - current_step: null が追加される
  - migrate()がtrueを返す
  - バックアップファイルが作成される
- **テストデータ**: 上記入力JSON

#### TC-U-024: migrate_completed_steps追加_pending

- **目的**: pending状態のフェーズにcompleted_stepsが追加されることを検証
- **前提条件**: metadata.jsonにcompleted_stepsフィールドが存在しない
- **入力**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "pending"
      }
    }
  }
  ```
- **期待結果**:
  - completed_steps: [] が追加される
  - current_step: null が追加される
- **テストデータ**: 上記入力JSON

#### TC-U-025: migrate_completed_steps追加_in_progress

- **目的**: in_progress状態のフェーズにcompleted_stepsが追加されることを検証
- **前提条件**: metadata.jsonにcompleted_stepsフィールドが存在しない
- **入力**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress"
      }
    }
  }
  ```
- **期待結果**:
  - completed_steps: [] が追加される
  - current_step: 'execute' が設定される
- **テストデータ**: 上記入力JSON

#### TC-U-026: migrate_completed_steps追加_completed

- **目的**: completed状態のフェーズにcompleted_stepsが追加されることを検証
- **前提条件**: metadata.jsonにcompleted_stepsフィールドが存在しない
- **入力**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "completed"
      }
    }
  }
  ```
- **期待結果**:
  - completed_steps: ['execute', 'review', 'revise'] が追加される
  - current_step: null が設定される
- **テストデータ**: 上記入力JSON

#### TC-U-027: migrate_バックアップ作成

- **目的**: マイグレーション前にバックアップファイルが作成されることを検証
- **前提条件**: マイグレーションが必要なmetadata.jsonが存在
- **入力**: TC-U-023の入力データ
- **期待結果**:
  - `metadata.json.backup_YYYYMMDD_HHMMSS` が作成される
  - バックアップファイルの内容が元のmetadata.jsonと同じ
- **テストデータ**: TC-U-023の入力データ

#### TC-U-028: migrate_既にマイグレーション済み

- **目的**: 既にマイグレーション済みの場合、何もしないことを検証
- **前提条件**: current_stepとcompleted_stepsが既に存在
- **入力**:
  ```json
  {
    "phases": {
      "requirements": {
        "status": "in_progress",
        "current_step": null,
        "completed_steps": []
      }
    }
  }
  ```
- **期待結果**:
  - migrate()がfalseを返す
  - メタデータが変更されない
  - バックアップが作成されない
- **テストデータ**: 上記入力JSON

---

## 2. Integrationテストシナリオ

### 2.1 BasePhase.run() - ステップ実行フロー

#### TC-I-001: execute_review_revise完全フロー

**シナリオ名**: Requirements Phase の完全実行フロー（execute → review → revise）

- **目的**: 各ステップ後にコミット＆プッシュが実行され、メタデータが正しく更新されることを検証
- **前提条件**:
  - Gitリポジトリが初期化され、リモートブランチ `ai-workflow/issue-123` が存在
  - Requirements Phaseが未実行（status: 'pending'）
- **テスト手順**:
  1. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  2. execute()が成功し、requirements.mdが生成される
  3. Gitコミット＆プッシュが実行される（1回目）
  4. review()が実行され、失敗する（意図的な失敗）
  5. Gitコミット＆プッシュが実行される（2回目）
  6. revise()が実行され、成功する
  7. Gitコミット＆プッシュが実行される（3回目）
- **期待結果**:
  - Gitログに3つのコミットが存在:
    - `[ai-workflow] Phase 1 (requirements) - execute completed`
    - `[ai-workflow] Phase 1 (requirements) - review completed`
    - `[ai-workflow] Phase 1 (requirements) - revise completed`
  - metadata.jsonの状態:
    ```json
    {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review", "revise"]
    }
    ```
  - リモートブランチにも3つのコミットがプッシュされている
- **確認項目**:
  - [ ] executeステップ後にローカルコミットが作成される
  - [ ] executeステップ後にリモートプッシュが成功する
  - [ ] metadata.jsonのcurrent_stepが'execute'→null→'review'と遷移する
  - [ ] reviewステップ後にローカルコミットが作成される
  - [ ] reviewステップ後にリモートプッシュが成功する
  - [ ] reviseステップ後にローカルコミットが作成される
  - [ ] reviseステップ後にリモートプッシュが成功する
  - [ ] フェーズステータスが'completed'になる

#### TC-I-002: execute_review成功フロー

**シナリオ名**: Requirements Phase のレビュー成功フロー（execute → review）

- **目的**: レビューが成功した場合、reviseがスキップされることを検証
- **前提条件**: TC-I-001と同じ
- **テスト手順**:
  1. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  2. execute()が成功し、requirements.mdが生成される
  3. Gitコミット＆プッシュが実行される（1回目）
  4. review()が実行され、成功する
  5. Gitコミット＆プッシュが実行される（2回目）
  6. revise()がスキップされる
- **期待結果**:
  - Gitログに2つのコミットが存在:
    - `[ai-workflow] Phase 1 (requirements) - execute completed`
    - `[ai-workflow] Phase 1 (requirements) - review completed`
  - metadata.jsonの状態:
    ```json
    {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review"]
    }
    ```
- **確認項目**:
  - [ ] reviseステップがスキップされる
  - [ ] completed_stepsに'revise'が含まれない
  - [ ] フェーズステータスが'completed'になる

#### TC-I-003: executeステップスキップ（レジューム）

**シナリオ名**: Execute完了後のレジューム（review から再開）

- **目的**: execute完了後のレジュームでexecuteがスキップされ、reviewから再開されることを検証
- **前提条件**:
  - executeステップが完了し、リモートにプッシュ済み
  - metadata.jsonの状態:
    ```json
    {
      "status": "in_progress",
      "current_step": null,
      "completed_steps": ["execute"]
    }
    ```
- **テスト手順**:
  1. ローカルワークスペースをリセット（git reset --hard、CI環境シミュレーション）
  2. リモートブランチから最新状態をpull
  3. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  4. executeステップがスキップされる
  5. reviewステップから再開される
- **期待結果**:
  - ログに "Skipping execute step (already completed)" が表示される
  - review()が実行される
  - Gitログに新しいコミット `[ai-workflow] Phase 1 (requirements) - review completed` が追加される
- **確認項目**:
  - [ ] execute()が呼び出されない
  - [ ] requirements.mdの再生成が行われない
  - [ ] review()が実行される
  - [ ] reviewステップ後にコミット＆プッシュが実行される

#### TC-I-004: current_step からのレジューム

**シナリオ名**: current_step='review' からのレジューム

- **目的**: current_stepが設定されている場合、そこから再開されることを検証
- **前提条件**:
  - metadata.jsonの状態:
    ```json
    {
      "status": "in_progress",
      "current_step": "review",
      "completed_steps": ["execute"]
    }
    ```
- **テスト手順**:
  1. リモートブランチから最新状態をpull
  2. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  3. ResumeManager.getResumeStep() が resumeStep='review' を返す
  4. executeステップがスキップされる
  5. reviewステップが実行される
- **期待結果**:
  - ログに "Resuming phase 'requirements' from step 'review'" が表示される
  - review()が実行される
- **確認項目**:
  - [ ] current_stepが優先的に使用される
  - [ ] completed_stepsに関係なくcurrent_stepから再開される

---

### 2.2 Git操作 - コミット＆プッシュ

#### TC-I-005: プッシュ成功（正常系）

**シナリオ名**: ステップコミット＆プッシュの正常動作

- **目的**: ステップ完了後にコミット＆プッシュが成功することを検証
- **前提条件**:
  - Gitリポジトリが初期化され、リモートブランチが存在
  - executeステップが完了
- **テスト手順**:
  1. BasePhase.commitAndPushStep('execute') を呼び出す
  2. GitManager.commitStepOutput() が実行される
  3. GitManager.pushToRemote(3) が実行される（最大3回リトライ）
  4. プッシュが成功する
- **期待結果**:
  - ローカルブランチにコミットが作成される
  - リモートブランチにコミットがプッシュされる
  - metadata.jsonのcompleted_stepsに'execute'が追加される
  - metadata.jsonのcurrent_stepがnullにリセットされる
- **確認項目**:
  - [ ] コミットハッシュが取得できる
  - [ ] リモートブランチにコミットが存在する
  - [ ] メタデータが正しく更新される

#### TC-I-006: プッシュ失敗（1回目成功）

**シナリオ名**: プッシュ1回目は失敗、2回目で成功

- **目的**: プッシュリトライ機能が正しく動作することを検証
- **前提条件**:
  - ネットワーク一時障害をシミュレート（モック）
  - 1回目のプッシュは失敗、2回目は成功
- **テスト手順**:
  1. BasePhase.commitAndPushStep('execute') を呼び出す
  2. GitManager.pushToRemote(3) が実行される
  3. 1回目のプッシュが失敗する（エラー: "network timeout"）
  4. 1秒待機後、2回目のプッシュが実行される
  5. 2回目のプッシュが成功する
- **期待結果**:
  - リトライログ "[INFO] Retrying push (attempt 2/3)..." が表示される
  - 2回目のプッシュが成功する
  - ステップが完了として記録される
- **確認項目**:
  - [ ] 1回目の失敗がログに記録される
  - [ ] リトライが実行される
  - [ ] 2回目の成功がログに記録される
  - [ ] completed_stepsに'execute'が追加される

#### TC-I-007: プッシュ失敗（3回リトライ後失敗）

**シナリオ名**: プッシュが3回リトライしても失敗

- **目的**: プッシュ失敗時にステップが未完了として記録されることを検証
- **前提条件**:
  - ネットワーク障害をシミュレート（モック）
  - すべてのプッシュが失敗する
- **テスト手順**:
  1. BasePhase.commitAndPushStep('execute') を呼び出す
  2. GitManager.pushToRemote(3) が実行される
  3. 1回目のプッシュが失敗する
  4. 1秒待機後、2回目のプッシュが失敗する
  5. 2秒待機後、3回目のプッシュが失敗する
  6. エラーがスローされる
- **期待結果**:
  - エラーログ "[ERROR] Phase requirements: Failed to push step execute: ..." が表示される
  - metadata.jsonのcurrent_stepが'execute'のまま維持される
  - metadata.jsonのcompleted_stepsに'execute'が追加されない
  - フェーズステータスが'failed'になる
- **確認項目**:
  - [ ] 3回のリトライがすべて実行される
  - [ ] リトライ間隔が1秒、2秒、4秒（指数バックオフ）
  - [ ] current_stepが維持される
  - [ ] ローカルコミットは存在する（プッシュのみ失敗）

#### TC-I-008: プッシュ失敗後のレジューム

**シナリオ名**: プッシュ失敗後、次回レジューム時に同じステップを再実行

- **目的**: プッシュ失敗時のレジューム動作を検証
- **前提条件**:
  - TC-I-007でプッシュが失敗した状態
  - metadata.jsonの状態:
    ```json
    {
      "status": "failed",
      "current_step": "execute",
      "completed_steps": []
    }
    ```
- **テスト手順**:
  1. ネットワーク障害が復旧（モック解除）
  2. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  3. ResumeManager.getResumeStep() が resumeStep='execute' を返す
  4. executeステップが最初から再実行される
  5. コミット＆プッシュが成功する
- **期待結果**:
  - ログに "Resuming phase 'requirements' from step 'execute'" が表示される
  - execute()が再実行される
  - 今回はプッシュが成功する
  - completed_stepsに'execute'が追加される
- **確認項目**:
  - [ ] executeステップが再実行される
  - [ ] 前回のローカルコミットは破棄される（新規コミット作成）
  - [ ] プッシュが成功する
  - [ ] current_stepがnullにリセットされる

---

### 2.3 CI環境 - リモート同期

#### TC-I-009: CI環境でのレジューム（execute完了後）

**シナリオ名**: Jenkins Build #1でexecute完了、Build #2でreviewから再開

- **目的**: CI環境でワークスペースリセット後も正しくレジュームできることを検証
- **前提条件**:
  - Jenkins環境（各ビルドでワークスペースがリセットされる）
  - Build #1でexecuteステップが完了し、リモートにプッシュ済み
- **テスト手順**:
  1. **Jenkins Build #1**:
     - `git checkout -b ai-workflow/issue-123`
     - `ai-workflow-v2 execute --phase requirements --issue 123`
     - executeステップが完了し、コミット＆プッシュ成功
     - reviewステップで失敗（意図的）
     - ビルド終了（ワークスペース削除）
  2. **Jenkins Build #2**（レジューム）:
     - `git clone <repo> && git checkout ai-workflow/issue-123`
     - `git pull origin ai-workflow/issue-123`（最新状態を取得）
     - metadata.json読み込み（completed_steps: ["execute"]）
     - `ai-workflow-v2 execute --phase requirements --issue 123`
     - executeステップがスキップされる
     - reviewステップから再開される
- **期待結果**:
  - Build #2のログに "Skipping execute step (already completed)" が表示される
  - review()が実行される
  - トークン消費量がexecuteステップ分削減される
- **確認項目**:
  - [ ] リモートブランチからmetadata.jsonが正しく取得される
  - [ ] completed_stepsが正しく解釈される
  - [ ] executeステップがスキップされる
  - [ ] reviewステップが実行される

#### TC-I-010: CI環境でのリモート同期（複数ステップ）

**シナリオ名**: Jenkins Build #1でexecute+review完了、Build #2でreviseから再開

- **目的**: 複数ステップ完了後のCI環境でのレジュームを検証
- **前提条件**:
  - Build #1でexecuteとreviewステップが完了し、リモートにプッシュ済み
  - metadata.jsonの状態:
    ```json
    {
      "status": "in_progress",
      "current_step": null,
      "completed_steps": ["execute", "review"]
    }
    ```
- **テスト手順**:
  1. **Jenkins Build #2**:
     - ワークスペースリセット
     - `git clone <repo> && git checkout ai-workflow/issue-123`
     - `git pull origin ai-workflow/issue-123`
     - metadata.json読み込み
     - `ai-workflow-v2 execute --phase requirements --issue 123`
     - executeとreviewステップがスキップされる
     - reviseステップから再開される
- **期待結果**:
  - ログに "Skipping execute step (already completed)" が表示される
  - ログに "Skipping review step (already completed)" が表示される
  - revise()が実行される
- **確認項目**:
  - [ ] 複数のステップがスキップされる
  - [ ] 正しいステップから再開される
  - [ ] completed_stepsが正しく更新される

#### TC-I-011: CI環境でのプッシュ失敗とリカバリー

**シナリオ名**: Jenkins Build #1でプッシュ失敗、Build #2でリトライ成功

- **目的**: CI環境でのプッシュ失敗とリカバリー動作を検証
- **前提条件**:
  - Build #1でexecuteステップが完了したが、プッシュが失敗
  - ローカルコミットはワークスペースリセットで消失
  - metadata.jsonの状態（リモート）:
    ```json
    {
      "status": "failed",
      "current_step": "execute",
      "completed_steps": []
    }
    ```
- **テスト手順**:
  1. **Jenkins Build #2**:
     - ワークスペースリセット
     - `git clone <repo> && git checkout ai-workflow/issue-123`
     - `git pull origin ai-workflow/issue-123`
     - metadata.json読み込み（current_step: "execute"）
     - `ai-workflow-v2 execute --phase requirements --issue 123`
     - executeステップが最初から再実行される
     - 今回はプッシュが成功する
- **期待結果**:
  - executeステップが再実行される
  - プッシュが成功する
  - metadata.jsonが正しく更新される
- **確認項目**:
  - [ ] current_stepから再実行される
  - [ ] 前回のローカルコミットは存在しない（ワークスペースリセット）
  - [ ] 新しいコミットが作成される
  - [ ] プッシュが成功する

---

### 2.4 メタデータマイグレーション

#### TC-I-012: 既存ワークフローのマイグレーション

**シナリオ名**: 古いスキーマのmetadata.jsonを新しいスキーマにマイグレーション

- **目的**: 既存ワークフローが新しいスキーマに自動的にマイグレーションされることを検証
- **前提条件**:
  - 古いスキーマのmetadata.jsonが存在（current_step、completed_stepsフィールドなし）
  - planning、requirementsフェーズがcompleted状態
  - designフェーズがin_progress状態
- **テスト手順**:
  1. WorkflowState.migrate() を呼び出す
  2. 各フェーズにcurrent_stepとcompleted_stepsフィールドが追加される
  3. metadata.json.backupが作成される
  4. metadata.jsonが保存される
- **期待結果**:
  - **planningフェーズ**:
    ```json
    {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review", "revise"]
    }
    ```
  - **requirementsフェーズ**:
    ```json
    {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review", "revise"]
    }
    ```
  - **designフェーズ**:
    ```json
    {
      "status": "in_progress",
      "current_step": "execute",
      "completed_steps": []
    }
    ```
  - metadata.json.backup_YYYYMMDD_HHMMSSが作成される
- **確認項目**:
  - [ ] completedフェーズは全ステップ完了と仮定される
  - [ ] in_progressフェーズはexecuteから再開と仮定される
  - [ ] バックアップファイルが作成される
  - [ ] ログに "[OK] metadata.json migrated successfully" が表示される

#### TC-I-013: マイグレーション後のワークフロー実行

**シナリオ名**: マイグレーション後、既存ワークフローが正常に動作する

- **目的**: マイグレーション後も既存ワークフローが影響を受けないことを検証
- **前提条件**:
  - TC-I-012でマイグレーションが完了
  - designフェーズがin_progress、current_step='execute'
- **テスト手順**:
  1. `ai-workflow-v2 execute --phase design --issue 123` を実行
  2. executeステップから開始される
  3. コミット＆プッシュが成功する
  4. reviewステップが実行される
- **期待結果**:
  - designフェーズが正常に実行される
  - ステップ単位のコミット＆プッシュが動作する
  - 既存のplanningとrequirementsフェーズに影響がない
- **確認項目**:
  - [ ] マイグレーション後も正常にワークフロー実行できる
  - [ ] ステップ管理機能が正しく動作する
  - [ ] 既存フェーズのメタデータが保持される

#### TC-I-014: マイグレーション失敗時のロールバック

**シナリオ名**: マイグレーション失敗時にバックアップからロールバック

- **目的**: マイグレーション失敗時のリカバリー手順を検証
- **前提条件**:
  - metadata.jsonが破損している（不正なJSON）
- **テスト手順**:
  1. WorkflowState.migrate() を呼び出す
  2. マイグレーションが失敗する
  3. エラーログが出力される
  4. 手動でmetadata.json.backupから復元する
- **期待結果**:
  - エラーログ "[ERROR] Migration failed: ..." が表示される
  - metadata.json.backupが存在する
  - バックアップから復元可能
- **確認項目**:
  - [ ] マイグレーション失敗がログに記録される
  - [ ] バックアップファイルが作成されている
  - [ ] バックアップファイルの内容が正しい

---

### 2.5 エラーハンドリング

#### TC-I-015: execute失敗時の動作

**シナリオ名**: executeステップが失敗した場合の動作

- **目的**: executeステップ失敗時にコミットが作成されず、フェーズがfailedになることを検証
- **前提条件**:
  - Requirements Phaseが未実行
  - execute()が失敗する設定（モック）
- **テスト手順**:
  1. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  2. execute()が失敗する
  3. エラーハンドリングが実行される
- **期待結果**:
  - Gitコミットが作成されない
  - metadata.jsonの状態:
    ```json
    {
      "status": "failed",
      "current_step": "execute",
      "completed_steps": []
    }
    ```
  - エラーログ "[ERROR] Phase requirements: Execute failed: ..." が表示される
- **確認項目**:
  - [ ] execute失敗時にコミットが作成されない
  - [ ] current_stepが'execute'のまま維持される
  - [ ] completed_stepsが空配列のまま
  - [ ] フェーズステータスが'failed'になる

#### TC-I-016: review失敗→revise成功

**シナリオ名**: reviewステップが失敗し、reviseで修正成功

- **目的**: review失敗時にreviseが自動的に実行され、成功することを検証
- **前提条件**:
  - executeステップが完了
  - review()が失敗する設定（モック）
  - revise()が成功する設定（モック）
- **テスト手順**:
  1. executeステップが完了し、コミット＆プッシュ成功
  2. reviewステップが実行され、失敗する
  3. reviewステップ完了としてコミット＆プッシュ（失敗結果も記録）
  4. reviseステップが自動的に実行される
  5. reviseステップが成功し、コミット＆プッシュ
- **期待結果**:
  - Gitログに3つのコミット:
    - `[ai-workflow] Phase 1 (requirements) - execute completed`
    - `[ai-workflow] Phase 1 (requirements) - review completed`
    - `[ai-workflow] Phase 1 (requirements) - revise completed`
  - metadata.jsonの状態:
    ```json
    {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review", "revise"]
    }
    ```
- **確認項目**:
  - [ ] review失敗時もコミットが作成される
  - [ ] reviseが自動的に実行される
  - [ ] revise成功後にフェーズがcompletedになる

#### TC-I-017: メタデータ不整合の検出

**シナリオ名**: current_stepとcompleted_stepsに矛盾がある場合の動作

- **目的**: メタデータ不整合時のフォールバック動作を検証
- **前提条件**:
  - metadata.jsonが不整合な状態（手動編集）:
    ```json
    {
      "status": "in_progress",
      "current_step": "execute",
      "completed_steps": ["execute", "review"]
    }
    ```
    （executeが完了しているのにcurrent_stepが'execute'）
- **テスト手順**:
  1. `ai-workflow-v2 execute --phase requirements --issue 123` を実行
  2. ResumeManager.getResumeStep() がメタデータ不整合を検出
  3. 警告ログが出力される
  4. 安全側にフォールバック（current_stepを優先）
- **期待結果**:
  - 警告ログ "[WARNING] Metadata inconsistency detected: current_step is 'execute' but already in completed_steps" が表示される
  - current_stepが優先され、executeステップが再実行される
  - ワークフローが継続する（停止しない）
- **確認項目**:
  - [ ] メタデータ不整合が検出される
  - [ ] 警告ログが出力される
  - [ ] 安全側にフォールバック（最初から再実行）
  - [ ] ワークフローが停止しない

---

## 3. テストデータ

### 3.1 正常系テストデータ

#### データセット1: 新規ワークフロー

```json
{
  "issue_number": "123",
  "phases": {
    "planning": {
      "status": "pending",
      "current_step": null,
      "completed_steps": [],
      "retry_count": 0
    },
    "requirements": {
      "status": "pending",
      "current_step": null,
      "completed_steps": [],
      "retry_count": 0
    }
  }
}
```

#### データセット2: execute完了後

```json
{
  "issue_number": "123",
  "phases": {
    "requirements": {
      "status": "in_progress",
      "current_step": null,
      "completed_steps": ["execute"],
      "retry_count": 0,
      "output_files": {
        "execute": ".ai-workflow/issue-123/01_requirements/output/requirements.md"
      }
    }
  }
}
```

#### データセット3: execute+review完了後

```json
{
  "issue_number": "123",
  "phases": {
    "requirements": {
      "status": "in_progress",
      "current_step": null,
      "completed_steps": ["execute", "review"],
      "retry_count": 0,
      "output_files": {
        "execute": ".ai-workflow/issue-123/01_requirements/output/requirements.md"
      }
    }
  }
}
```

### 3.2 異常系テストデータ

#### データセット4: プッシュ失敗（execute）

```json
{
  "issue_number": "123",
  "phases": {
    "requirements": {
      "status": "failed",
      "current_step": "execute",
      "completed_steps": [],
      "retry_count": 0
    }
  }
}
```

#### データセット5: メタデータ不整合

```json
{
  "issue_number": "123",
  "phases": {
    "requirements": {
      "status": "in_progress",
      "current_step": "execute",
      "completed_steps": ["execute", "review"],
      "retry_count": 0
    }
  }
}
```

### 3.3 マイグレーション用テストデータ

#### データセット6: 旧スキーマ（マイグレーション前）

```json
{
  "issue_number": "123",
  "phases": {
    "planning": {
      "status": "completed",
      "retry_count": 0
    },
    "requirements": {
      "status": "in_progress",
      "retry_count": 0
    }
  }
}
```

#### データセット7: 新スキーマ（マイグレーション後）

```json
{
  "issue_number": "123",
  "phases": {
    "planning": {
      "status": "completed",
      "current_step": null,
      "completed_steps": ["execute", "review", "revise"],
      "retry_count": 0
    },
    "requirements": {
      "status": "in_progress",
      "current_step": "execute",
      "completed_steps": [],
      "retry_count": 0
    }
  }
}
```

---

## 4. テスト環境要件

### 4.1 ローカル開発環境

- **OS**: macOS / Linux / Windows（WSL2推奨）
- **Node.js**: 20以上
- **npm**: 10以上
- **Git**: 2.30以上
- **TypeScript**: 5.x

### 4.2 CI/CD環境

- **Jenkins**: 2.x以上
- **Docker**: 20.x以上（Jenkinsエージェント）
- **環境変数**:
  - `GITHUB_TOKEN`: GitHub パーソナルアクセストークン
  - `GITHUB_REPOSITORY`: `owner/repo` 形式
  - `GIT_COMMIT_USER_NAME`: Gitコミット作成者名
  - `GIT_COMMIT_USER_EMAIL`: Gitコミット作成者メール

### 4.3 外部サービス

- **GitHub**: リモートリポジトリ、Issue、PR
- **Claude API**: AIエージェント（モック可）

### 4.4 モック/スタブの必要性

#### Unitテストでモックが必要な箇所

1. **GitManager**:
   - `simple-git` ライブラリのモック
   - コミット成功/失敗のシミュレーション
   - プッシュ成功/失敗のシミュレーション

2. **MetadataManager**:
   - ファイルシステム操作（`fs-extra`）のモック
   - metadata.json読み書きのモック

3. **ResumeManager**:
   - MetadataManagerのモック

#### Integrationテストでモックが必要な箇所

1. **Claude API**:
   - execute()、review()、revise()の成功/失敗をモック
   - トークン消費量の測定（モック）

2. **ネットワーク障害**:
   - プッシュ失敗をシミュレート
   - リトライ動作の検証

---

## 5. 受け入れ基準とのマッピング

| 受け入れ基準 | 対応するテストケース | テスト種別 |
|------------|-------------------|----------|
| AC-1: Execute ステップ後のGitコミット＆プッシュ | TC-I-001, TC-I-002, TC-I-005 | Integration |
| AC-2: Review ステップ後のGitコミット＆プッシュ | TC-I-001, TC-I-002, TC-I-005 | Integration |
| AC-3: Revise ステップ後のGitコミット＆プッシュ | TC-I-001, TC-I-016 | Integration |
| AC-4: メタデータにcurrent_stepが記録される | TC-U-001, TC-U-002, TC-I-001 | Unit + Integration |
| AC-5: Execute完了後のレジューム（CI環境） | TC-I-003, TC-I-009 | Integration |
| AC-6: プッシュ失敗後の動作 | TC-I-007, TC-I-008, TC-I-011 | Integration |
| AC-7: フェーズ完了後のGitログ | TC-I-001, TC-U-010, TC-U-011 | Unit + Integration |
| AC-8: メタデータマイグレーション | TC-U-023~TC-U-028, TC-I-012, TC-I-013 | Unit + Integration |
| AC-9: CI環境でのリモート同期 | TC-I-009, TC-I-010, TC-I-011 | Integration |
| AC-10: TypeScript型安全性 | コンパイルチェック（npm run build） | Compile-time |

---

## 6. 品質ゲート確認

### Phase 3の品質ゲート

- [x] **Phase 2の戦略に沿ったテストシナリオである**
  - UNIT_INTEGRATIONに準拠
  - Unitテスト: TC-U-001 〜 TC-U-028 (28ケース)
  - Integrationテスト: TC-I-001 〜 TC-I-017 (17ケース)

- [x] **主要な正常系がカバーされている**
  - TC-I-001: execute → review → revise の完全フロー
  - TC-I-002: execute → review の成功フロー
  - TC-I-003: executeスキップ（レジューム）
  - TC-I-005: プッシュ成功
  - TC-I-012: メタデータマイグレーション

- [x] **主要な異常系がカバーされている**
  - TC-I-007: プッシュ失敗（3回リトライ後）
  - TC-I-008: プッシュ失敗後のレジューム
  - TC-I-015: execute失敗
  - TC-I-017: メタデータ不整合

- [x] **期待結果が明確である**
  - すべてのテストケースで期待結果を明記
  - 具体的な出力例（JSONデータ、ログメッセージ）を記載
  - 確認項目をチェックリスト形式で明示

---

## 7. テスト実行計画

### 7.1 Unitテスト実行

```bash
# すべてのUnitテストを実行
npm run test:unit

# 特定のテストファイルのみ実行
npm run test tests/unit/step-management.test.ts

# カバレッジ測定
npm run test:coverage
```

**期待カバレッジ**: 90%以上（新規メソッドのみ）

### 7.2 Integrationテスト実行

```bash
# すべてのIntegrationテストを実行
npm run test:integration

# 特定のシナリオのみ実行
npm run test tests/integration/step-commit-push.test.ts

# CI環境シミュレーション
npm run test tests/integration/step-resume.test.ts
```

### 7.3 CI/CDパイプラインでのテスト

```groovy
// Jenkinsfile
stage('Test') {
  steps {
    sh 'npm run test:unit'
    sh 'npm run test:integration'
    sh 'npm run test:coverage'
  }
}
```

---

## 8. テストスケジュール

| フェーズ | 期間 | 内容 |
|---------|------|------|
| Unitテスト実装 | 1~1.5h | TC-U-001 〜 TC-U-028 の実装 |
| Integrationテスト実装 | 1~1.5h | TC-I-001 〜 TC-I-017 の実装 |
| テスト実行と修正 | 1~2h | すべてのテストを実行し、失敗したケースを修正 |
| カバレッジ確認 | 0.5h | カバレッジレポート生成と分析 |

**合計**: 3.5~5時間

---

## 9. リスクと軽減策

### リスク1: CI環境での統合テスト実行が困難

- **影響度**: 中
- **確率**: 中
- **軽減策**:
  - Docker環境でCI環境をシミュレート
  - モックを使用してワークスペースリセットを再現
  - 実際のJenkinsパイプラインでテスト実行を確認

### リスク2: Git操作のモックが複雑

- **影響度**: 中
- **確率**: 低
- **軽減策**:
  - `simple-git-mock` ライブラリを使用
  - テスト用のGitリポジトリを実際に作成して実行
  - コミット＆プッシュの成功/失敗をシンプルにモック

### リスク3: テストデータの準備が煩雑

- **影響度**: 低
- **確率**: 中
- **軽減策**:
  - テストデータをJSON形式でファイル化
  - テストヘルパー関数でメタデータを簡単に生成
  - フィクスチャファイルを活用

---

## 10. 参考情報

- **Planning Document**: `.ai-workflow/issue-10/00_planning/output/planning.md`
- **Requirements Document**: `.ai-workflow/issue-10/01_requirements/output/requirements.md`
- **Design Document**: `.ai-workflow/issue-10/02_design/output/design.md`
- **CLAUDE.md**: プロジェクトの全体方針とコーディングガイドライン
- **ARCHITECTURE.md**: アーキテクチャ設計思想
- **Issue #10**: https://github.com/tielec/ai-workflow-agent/issues/10

---

**作成日**: 2025-01-XX
**Issue**: #10
**Phase**: Test Scenario (Phase 3)
**Status**: Draft
